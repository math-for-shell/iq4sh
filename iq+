#!/bin/sh
# iq+ - Extended version of the iq calculator with added functions

# Copyright Gilbert Ashley 9 January 2022
# Contact: OldGringo9876@gmx.de  Subject-line: IQ4sh

# List of functions included here: pow, nroot, logx, exp, ipow, epow
# Back-end functions: fpow, nrt_solv, smplfy, exp_z, getE
# Miscellaneous functions: factorial, gcf, getP, getPhi

# removed is_num
# fpow - streamlined method slightly
# standardize help usage
# restore use of 'src=1' when sourcing iq

# disable some style checks and un-helpful suggestions
# shellcheck disable=SC2034,SC2086,SC2295,SC2004,SC1090,SC1091,SC2120,SC2154,SC2123

iqplusversion=1.71
defprec=${defprec:-5}

# set some constants - 'e' 'pi' 'phi'
EE=2.718281828459045235360287471352
# short versions are 11 places
ee=2.71828182845
PI=3.141592653589793238462643383279
pi=3.14159265358
PHI=1.61803398874989484820458683436
phi=1.61803398874

# pow - raises a decimal number to a given power (3.14 ^-4.12)
# depends on: 'mul' 'ipow/epow' 'smplfy' 'nroot' 'div'
# exponents can be simple, mixed and/or negative, like: 2.36 ^ -4.62
pow_help() {
echo "   'pow' requires 2 inputs: 'pow [-s?] base [^] exponent'
    Example usage: 'pow -s5 3.14 ^ -4.12' for:(3.14^-4.12)
    Fractional exponents >3 digits (x^2.3754) are not recommended." 
}
pow() { scale_pow=$defprec
    case $1 in -s*) scale_pow=${1#*-s} ; shift ;; ''|-h) pow_help >&2 ; return 1 ;;esac
    pbase=$1 ; shift ; case $1 in '^') shift ;;esac
    case $1 in '') pow_help >&2 ; return 1 ;;esac
    pexp=$1 pexpneg='' pbaseneg=''
    # separate and remove neg signs
    case $pbase in '-'*) pbaseneg='-' pbase=${pbase#*?} ;;esac
    case $pexp in '-'*) pexpneg='-' pexp=${pexp#?*} ;;esac
    # separate integer and fractional parts
    case $pbase in .?*) pbase_int=0 pbasefrac=${pbase#*.} ;; *?.?*) pbase_int=${pbase%.*} pbasefrac=${pbase#*.} ;;
        *) pbase_int=$pbase pbasefrac=0 ;;esac
    case $pexp in .?*) pexp_int=0 pexpfrac=${pexp#*.} ;; *?.?*) pexp_int=${pexp%.*} pexpfrac=${pexp#*.} ;;
        *) pexp_int=$pexp pexpfrac=0 ;;esac
    # remove extra leading zeros from integers
    while : ;do case $pbase_int in '0'?*) pbase_int=${pbase_int#?*} ;; *) break ;;esac ;done
    while : ;do case $pexp_int in '0'?*) pexp_int=${pexp_int#?*} ;; *) break ;;esac ;done
    # remove extra trailing zeros from fractions
    while : ;do case $pbasefrac in *?'0') pbasefrac=${pbasefrac%?*} ;; *) break ;;esac ;done
    while : ;do case $pexpfrac in *?'0') pexpfrac=${pexpfrac%?*} ;; *) break ;;esac ;done
    # recombine
    pbase=$pbase_int'.'$pbasefrac  pexp=$pexp_int'.'$pexpfrac
    case "$pbaseneg""$pbase" in
        0.0) case "$pexpneg""$pexp" in -*) echo "-->pow: NaN" >&2 ; return 1 ;;  
                0.0) echo 1.0 ; return ;; *) echo 0.0 ; return ;;esac ;;
        1.0) echo 1.0 ; return ;;
        -*) [ "$pexpfrac" != 0 ] && { echo "-->pow: NaN" >&2 ; return 1 ;}
            [ $((pexp_int%2)) -eq 0 ] && pbaseneg='' ;;
    esac
    case "$pexpneg""$pexp" in
        0.0) echo 0.0 ; return ;; 1.0) echo $pbaseneg$pbase ; return ;;
        -1.0) div -s$scale_pow  1 / $pbaseneg$pbase ; return ;;
    esac
    
    # estimate a useful internal scale for pow as there are several intermediate steps
    pmed_scale=$(( (scale_pow * 18) / 10 ))
    case $pexp_int in 
        0) pres=1.0 ;;     # exponent is less than 1, so do nothing here
        1) pres=$pbase_int'.'$pbasefrac ;;
        2) pres=$( mul -s$pmed_scale $pbase_int'.'$pbasefrac  $pbase_int'.'$pbasefrac) ;;
        *) pres=$( ipow -s$pmed_scale $pbase_int'.'$pbasefrac $pexp_int ) ;;
    esac
    # handle fractional exponents
    if [ "${pexpfrac}" != 0 ] ; then
        simple_frac=$(smplfy '.'$pexpfrac)
        nom=${simple_frac%/*} denom=${simple_frac#*/}
        nth_root=$( nroot -s$pmed_scale $pbase_int.$pbasefrac $denom )
        case $nom in
            1) pres=$( mul -s$pmed_scale $pres $nth_root ) ;;
            *)  nth=$( ipow -s$pmed_scale $nth_root $nom )
                pres=$( mul -s$pmed_scale $pres $nth ) ;;
        esac
    fi
    # if the exponent is negative, invert the result
    case $pexpneg in '-') pres=$( div -s$pmed_scale 1 / $pres ) ;;esac
    # truncate or trim to scale
    case $scale_pow in 0) echo $pbaseneg${pres%.*} ;; *) pfrac=${pres#*.} 
        while [ ${#pfrac} -gt $scale_pow ] ;do pfrac=${pfrac%?*} ;done
        echo $pbaseneg${pres%.*}'.'${pfrac:-0} ;; 
    esac
    #pbaseneg='' pexpneg=''
} ## pow
# scale_pow= pbase= pexp= pbaseneg= pexpneg= pbase_int= pbasefrac= i_scale= pmed_scale=
# pres= simple_frac nom= denom= nth_root= nth= pfrac=

# ipow - raises a decimal number to an integer power
# depends on: 'epow' 'logx' 'mul' 'div'
ipow_help() {
echo "  'ipow' requires 2 inputs: 'ipow [-s?] base [^] exponent'
    Example usage: 'ipow -s5 3.14 ^ -4' for:(3.14^-4)
    The base must be a positive number, either integer or mixed.
    Exponents can be negative or positive, but must be integers."
}
ipow(){ mp_prec=$defprec
    case $1 in -s*) mp_prec=${1#*-s} ; shift ;; ''|-h) ipow_help >&2 ; return 1 ;;  esac
    basemp=$1 ; shift ; case $1 in '^') shift ;;esac
    case $basemp in '-'*) echo "->ipow: negative bases not supported: $basemp" >&2 ; return 1 ;;esac
    case $1 in '') ipow_help >&2 ; return 1 ;; 
        *.*) echo "->ipow: fractional exponents not supported: $1" >&2 ; return 1 ;;
        *) expmp=$1 ;;
    esac
    #case $basemp in '-'*) mpneg='' basemp=${basemp#*-} ; [ $((expmp%2)) -eq 1 ] && mpneg='-' ;;esac
    case $expmp in '-'*) expmpneg='-' expmp=${expmp##*-}  ;;esac
    case $basemp in 
        0.*|.*) out_mp=$( epow -S$mp_prec $basemp $expmp )
                case $expmpneg in '-') div -s$mp_prec 1 / $out_mp ;; *) echo $out_mp ;;esac
                return ;;    # use epow for bases less than 1
        *.*) # a reliable minimum scale ~= (exp + int_size)/2
            #logmp=$(logx -s$mp_prec 10 $basemp)
            logmp=$(logx -s5 10 $basemp)    # 5X speedup
            # (log10(base) * exp) + 1 = integer size of result
            mpint_size=$(( $(mul -s0 $logmp $expmp) + 1 ))
            mpmin=$((expmp+mpint_size))  # trial and error led to using (exp+int_size)/2.2?, 
            # here we use 0.222*10  # mpmin=$(div -s0 $mpmin / 2.222)
            mpmin=$(mul -s0 $mpmin 0.450045)
            # now that we have the minimum, add enough extra to get proper answers
            gr=$(mul -s0 $mp_prec .61803398 )    # multiply by the inverse of phi
            rec_scale=$(( mpmin + gr ))
            [ $rec_scale -lt $mp_prec ] && rec_scale=$mp_prec ;;
        *) rec_scale=0 mp_prec=0 ;; # for integer bases, we can skip the expensive stuff above
    esac
    # do the operation
    out_mp=1
    while : ; do
        [ $((expmp%2)) -ne 0 ] && out_mp=$( mul -s$rec_scale $out_mp $basemp ) 
        expmp=$((expmp/2))
        [ $expmp -eq 0 ] && break
        basemp=$( mul -s$rec_scale $basemp $basemp )
    done
    # negative exponent
    case $expmpneg in '-'*) 
        [ $mp_prec -le ${#out_mp} ] && mpdiv_scale=$(( ${#out_mp} + $mp_prec )) || mpdiv_scale=$mp_prec
        out_mp=$( div -s$mpdiv_scale 1 / $out_mp ) ;;
    esac
    # format the output
    case $mp_prec in 0) echo ${out_mp%.*} ;;
        *)  out_frac_mp=${out_mp#*.}
            while [ ${#out_frac_mp} -gt $mp_prec ] ; do 
                out_frac_mp=${out_frac_mp%?*}
            done
            echo ${out_mp%.*}'.'$out_frac_mp ;;
    esac
} ## ipow
# mp_prec= basemp= expmp= basemp_frac= maxmp= logmp= mpint_size= 
# mpmin= gr= rec_scale= out_mp= out_frac_mp=

# epow - pow function which returns answers in normal scale, SigFig scale or e-notation
# used by ipow for bases X<1
# example: epow -e6 0.0105 ^ 1000000000 = 1.174730e-1978810701 
epow_help()  {
echo "    'epow' requires 2 inputs: 'epow [-s?,-S,-e?] base [^] integer-exponent' 
    Raises a decimal number to a (+)integer power, with answers in three forms:
    normally-scaled outputs, significant digits or scientific notation.
    Output format is controlled with the three scaling options -s?, -S? or -e?.
    Example usage for normal scaling: 'epow -s7 0.14 5' returns: 0.0000537
    Example for significant digits: 'epow -S7 0.14 5' returns: 0.0000537824
    Example for scientific notation: 'epow -e7 0.14 5' returns: 5.37824e-5
    'epow' is especially useful with e-notation for very long answers."
}
epow() { fstprec=$defprec   # normal scaling             # sigfig scaling
    case $1 in -s*) fstprec=${1#*-s} ; shift ;; -S*) fstprec=${1#*-S}  SigScale=1 ; shift ;;
            # e-notation scaling       
        -e*) fstprec=${1#*-e} E_note=1 ; shift ;; ''|-h) epow_help >&2 ; return 1 ;;
    esac
    SigScale=${SigScale:-0} E_note=${E_note:-0}
    base=$1 ; shift ; case $1 in '^') shift ;;esac
    case $base in '-'*) epowneg='-'  base=${base#*-} ;;esac
    case $1 in '-'*) echo "->epow: Use 'pow' for negative exponents" >&2 ; return 1 ;;
        '') epow_help >&2 ; return 1 ;;
        *) exp=$1 ;;
    esac
    
    case $E_note in 1) fst_scale=$((fstprec+8)) ;; *) fst_scale=$((exp+fstprec+3)) ;;esac
    # for low scales or exponents over 1,000,000 -we need a small booost...
    [ ${#exp} -gt 7 ] && fst_scale=$(( fst_scale + (${#exp}-7) ))
    [ $fstprec -lt 7 ] && fst_scale=$(( fst_scale + 2 ))
    case $base in 
        0.0*|.0*) zeros=0 dummy=${base#*.}  # remove and count leading zeros
            while : ; do case $dummy in 0*) dummy=${dummy#*?} zeros=$((zeros+1)) ;; *) break ;;esac ; done
            # take the log of the rest
            bplog=$(logx -s5 10 '.'$dummy )
            # multiply the absolute value of the log by the exponent to determine the length of growth
            E=$(mul -s0 ${bplog#*-} $exp )
            # add in the leading zeros, which are (zeros * exp) and add back the sign
            E=$((E + (zeros*exp) )) E='-'$E ;;
        0.*|.*)     # like above, but without leading zeros in the base
            bplog=$(logx -s5 10 $base ) E=$(mul -s0 ${bplog#*-} $exp ) E='-'$E ;;
            #bplog=$(logx -s10 10 $base ) E=$(mul -s0 ${bplog#*-} $exp ) E='-'$E ;;
        *)  # integers need a '0' fraction which is later removed
            bplog=$(logx -s5 10 $base ) E=$(mul -s0 $exp $bplog)
            case $base in 
                *.*) #base_int=${base%.*} base_int_size=${#base_int}
                    [ 0 = "$E_note" ] && fst_scale=$(( E + fstprec + 5 )) ;; 
                *) base=$base'.0' is_int=1 ;;
            esac
            base='.'${base%.*}${base#*.} ;;
    esac
    # do the operation, after each multiplication, strip leading zeros from result
    out_pm=1
    while : ; do 
        if [ $((exp%2)) -ne 0 ] ; then
            out_pm=$( mul -s$fst_scale $out_pm $base ) 
            dummy=${out_pm#*.}
            while : ; do case $dummy in 0*) dummy=${dummy#*?} ;; *) break ;;esac ; done
            out_pm='0.'$dummy
        fi
        exp=$((exp/2))
        [ $exp -eq 0 ] && break
        base=$( mul -s$fst_scale $base $base )
        dummy=${base#*.}
        while : ; do case $dummy in 0*) dummy=${dummy#*?} ;; *) break ;;esac ; done
        base='0.'$dummy
    done
    
    # reconstruct the output
    if [ 1 = "$E_note" ] ; then
        case $E in -*) E=$((E-1)) ;;esac
        dummy=${out_pm#*.}  # remove the extra 8, unless fraction has terminated
        [ ${#dummy} -gt $fst_scale ] && dummy=${dummy%???????*}
        msk1=${dummy#*?} out_pm=${dummy%$msk1*}
        while [ ${#msk1} -gt $fstprec ] ; do msk1=${msk1%?*} ; done
        echo $epowneg$out_pm'.'${msk1:-0}'e'$E
    else
        case $E in 
            -*) cnt_p=0 pad='' E_abs=${E#*-}
                while [ $cnt_p -lt $E_abs ] ; do pad=$pad'0' cnt_p=$((cnt_p+1)); done
                cnt_p=0 dummy=$pad${out_pm#*.} out_pm=''
                case $SigScale in 1) fstprec=$(( $E_abs + fstprec )) 
                        while [ ${#dummy} -gt $fstprec ] ; do dummy=${dummy%?*} ; done
                        out_pm=$dummy
                    ;;
                    *)  while [ $cnt_p -lt $fstprec ] ; do 
                            cnt_p=$((cnt_p+1)) msk1=${dummy#*?} out_pm=$out_pm${dummy%$msk1*} dummy=$msk1
                        done ;;
                esac
                out_pm='0.'$out_pm
            ;;
            *)  dummy=${out_pm#*.}  # trim off extra unless input was integer or fraction terminates at shorter length
                [ 1 != "$is_int" ] && [ ${#dummy} -gt $fst_scale ] && dummy=${dummy%???*}
                cnt_p=-1 out_pm=''
                while [ $cnt_p -lt $E ] ; do 
                    cnt_p=$((cnt_p+1)) msk1=${dummy#*?} out_pm=$out_pm${dummy%$msk1*} dummy=$msk1
                done
                cnt_p=0 zeros=0 out_frac=''
                case $SigScale in 1) scratch=$dummy
                    while : ; do case $scratch in 0*) zeros=$((zeros+1)) scratch=${scratch#*?} ;; *) break ;;esac ; done
                esac
                fstprec=$((fstprec+zeros))
                while [ $cnt_p -lt $fstprec ] ; do 
                    cnt_p=$((cnt_p+1)) msk1=${dummy#*?} out_frac=$out_frac${dummy%$msk1*} dummy=$msk1
                done
                out_pm=$out_pm'.'${out_frac:-0}
            ;;
        esac
        [ 1 = "$is_int" ] && echo $epowneg${out_pm%.*} || echo $epowneg$out_pm
    fi
} ## epow
# fstprec= SigScale= E_note= base= exp= fst_scale= zeros= dummy= bplog= E= base_int= base_int_size= out_pm=
# msk1= cnt_p= scratch= out_frac

# nroot - find the 'n-th' root of a number
# depends on: 'nrt_solv' 'div'
nroot_help() {
echo "   'nroot' requires 2 inputs: 'nroot [-s?] num1 num2'
    Example usage: 'nroot -s6 4.3 10' for: 10th root of 4.3
    Returns the Nth root of an input value, where 'Nth' is an integer.
    Example usage: 'nroot -s6 4.3 10' for: 10th root of 4.3" 
}
nroot() { scale_nrt=$defprec
    case $1 in -s*) scale_nrt=${1#*-s} ; shift ;; ''|-h) nroot_help >&2 ; return 1  ;;esac
    case $2 in '') nroot_help >&2 ; return 1  ;; 
        *.*) echo "->nroot: Nth must be an integer" >&2 ; return 1 ;; 
    esac
    base_nrt=$1 N_th=$2 # get the inputs
    case $N_th in '-'*) Nth_neg='-' N_th=${N_th#*-} ;; esac # separate neg from nth
    while : ; do case $N_th in 0?*) N_th=${N_th#*?} ;; *) break ;; esac ; done # depad nth
    case $base_nrt in '-'*) nrt_neg='-' base_nrt=${base_nrt#*-} ;; esac # separate neg from base
    case $base_nrt in 0.*|.*) nrt_int=0 nrt_frac=${base_nrt#*.} ;; # separate base int and frac
        *.*) nrt_int=${base_nrt%.*} nrt_frac=${base_nrt#*.} ;; *) nrt_int=$base_nrt nrt_frac=0 ;;
    esac
    while : ; do case $nrt_int in 0?*) nrt_int=${nrt_int#*?} ;; *) break ;; esac ; done # depad base int
    while : ; do case $nrt_frac in *?0) nrt_frac=${nrt_frac%?*} ;; *) break ;; esac ; done # depad base frac
    base_nrt=$nrt_int'.'$nrt_frac
    # handle special cases
    case $nrt_neg$base_nrt in
        0.0) case "$Nth_neg""$N_th" in -*) echo "->nroot: NaN" >&2 ; return 1 ;;  
                0) echo 1.0 ; return ;; *) echo 0.0 ; return ;;esac ;;
        1.0) echo 1.0 ; return ;;
        -*) [ $((N_th%2)) -eq 0 ] && { echo "->nroot: NaN" >&2 ; return 1 ;} ;;
    esac
    case $Nth_neg$N_th in
        0) echo 0.0 ; return ;; 1) echo $nrt_neg$base_nrt ; return ;;
        -1) div -s$scale_nrt  1 / $nrt_neg$base_nrt ; return ;;
    esac
    # If we get here, do scale-compensation for small bases, or user requests scale=0
    if [ $scale_nrt -eq 0 ] ; then
        scale_nthrt=2
    else
        # a complete solution for bases <0.0?* would mean counting leading zeros, but let's try this
        case $base_nrt in 0.0*) scale_nthrt=$(( (scale_nrt*12) / 10 )) ;; *) scale_nthrt=$scale_nrt ;; esac
    fi
    # for Nth which are multiples of 10, break into chunks
    if [ $((N_th % 10)) -eq 0 ] ; then
        while [ $N_th -gt 9 ] ;do
            N_th=$((N_th / 10))
            base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt 10 )
        done
        [ $N_th -gt 1 ] && base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $N_th )
    else
        # otherwise use the longer method
        if [ $N_th -gt 9 ] ; then
            solved=0 # try using factors
            for try in 9 8 7 6 5 4 3 2 ;do
                if [ $((N_th % try)) -eq 0 ] ; then
                    N_th=$((N_th / try))
                    base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $try )
                    base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $N_th )
                    solved=1 ; break
                fi
            done
            # number is prime or its' smallest factor is >9
            [ 0 = "$solved" ] && base_nrt=$( nrt_solv -s$scale_nthrt $base_nrt $N_th )
        else
            # for small N_th
            base_nrt=$( nrt_solv -s$scale_nthrt $base_nrt $N_th )
        fi
    fi
    case $Nth_neg in '-') base_nrt=$( div -s$scale_nthrt 1 / $base_nrt ) ;; esac
    # messy(still) decomposition of intermediate scales and output
    case $scale_nthrt in "$scale_nrt") echo $nrt_neg$base_nrt ;; 
        *)  case $scale_nrt in 0) echo $nrt_neg${base_nrt%.*} ;;
                *)  nrt_frac=${base_nrt#*.} nrt_out_frac=
                    while [ ${#nrt_out_frac} -lt $scale_nrt ] ; do   
                        nrt_msk=${nrt_frac#*?} nrt_out_frac=$nrt_out_frac${nrt_frac%$nrt_msk*} nrt_frac=$nrt_msk
                    done
                    echo $nrt_neg${base_nrt%.*}'.'$nrt_out_frac ;;
            esac ;;
    esac
    
} ## nroot -s7 4.2 5 (for 5th root of 4.2)
# scale_nthrt= N_th= base_nrt= solved=

# logx - returns logarithms in base 10, e/n or 2
# depends on: 'tsst' 'mul' 'getE' 'div' 'add'
# This uses a fast approximation with good precision to about 11 places
# asking for more digits will break the result, so don't be greedy
# uses a power series for ln(x) and then converts to base 2 or 10 if needed
# ln(x) = 2{ (x-1/x+1) + 1/3(x-1/x+1)^3 + 1/5(x-1/x+1)^5 + ...}
logx_help() {
echo "    'logx' requires 2 inputs: 'logx [-s?] base num1'
    Example usage: 'logx -s8 10 2.2' for: log10(2.2)
    Example usage: 'logx -s7 n 6.7' for: ln(6.7)
    logx is a utility function, so it expects well-formed inputs."
}
logx() { scale_lx=$defprec
    case $1 in -s*) scale_lx=${1#*-s} ; shift ;; ''|-h) logx_help >&2 ; return 1 ;;esac
    case $2 in '') logx_help >&2 ; return 1 ;;esac
    base=$1 x=$2 # special cases and errors
    case $x in # input errors and logx(1) are universal for all bases
        -*) echo "-->logx: NaN" ; return 1 ;;
        0|0.0) echo "-->logx: NaN" ; return 1 ;; 
        1|1.0) echo 0.0 ; return ;;
    esac
    case $base in # base-specific errors and easy-outs
        10) # log10 easy outs - different for other bases
            case $x in 
                0.1|.1) echo '-1' ; return ;; 10|10.0) echo 1 ; return ;; 10'.'*) : ;;
                10*)  mask=${x#?*} ; tsst $mask -eq 0 && { echo ${#mask}'.0' ; return ;} ;;
                .0*|0.0*) frac=${x#*.} # possible 10â»n, if so: 0.01, 0.001, ..., return -1, -2, ...
                    tsst ${frac%1*} -eq 0  && { echo '-'${#frac}'.0' ; return ;} ;;
            esac ;; 
        2|n|e) : ;;
        *) echo "-->logx: False base input: e, n, 2 or 10 allowed" ; return 1 ;;
    esac
    e_scale=$(($scale_lx+2)) rank=0    # set the internal scale, then determine the characteristic/rank
    
    lxE=$(getE $e_scale)
    if tsst $x -lt 0.4 ; then
        case $x in  
            0.0*|.0*) while tsst $x -lt .4 ;do rank=$((rank-1)) x=$( mul -s$e_scale $x $lxE ) ;done ;;
            *) rank=-1 x=$( mul -s$e_scale $x $lxE ) ;;
        esac
    elif tsst $x -gt 2.8 ; then
        while tsst $x -gt 2.8 ;do rank=$((rank+1)) x=$( div -s$e_scale $x / $lxE ) ;done
    fi
    its=$((scale_lx+2))    # set the max number of iterations -using too many will ruin result
    case $x in 0.0*) echo "-->logx: how did we get here?" >&2 ; return 1 ;; # this happens when called incorrectly
        0.1*|0.2*) e_scale=$((scale_lx+6)) its=$(($scale_lx+6)) ;; 
        1.0*) d=${x#*.} z=0 ; while : ;do case $d in 0*) z=$((z+1)) d=${d#?*} ;; *) break ;;esac ;done
            e_scale=$((scale_lx+z+2)) ;;
    esac
    # get the initial ratio of (x-1/x+1) and initialize acu and total 
    x_m=$( add -s$e_scale $x - 1 )         x_p=$( add -s$e_scale $x + 1 )
    ratio=$( div -s$e_scale $x_m / $x_p )   total=$ratio acu=$ratio lxcnt=0 dvsr_series=3
    
    # do the iterations  (x-1/x+1)^3/3 ... (x-1/x+1)^5/5 ... (x-1/x+1)^7/7
    while [ $lxcnt -lt $its ] ;do
        acu=$( mul -s$e_scale $acu $ratio )    acu=$( mul -s$e_scale $acu $ratio )
        tsst ${acu#*-} -eq 0 && break
        #sub_total=$( div -s$e_scale $acu / $dvsr_series ) total=$( add $total $sub_total )
        sub_total=$( div -s$scale_lx $acu / $dvsr_series ) total=$( add $total $sub_total )
        lxcnt=$((lxcnt+1)) dvsr_series=$((dvsr_series+2))
    done
    lxout=$( mul -s$e_scale $total 2 )
    lxout=$( add -s$scale_lx $lxout $rank )
    # print or convert the output according to the base
    case $base in e|n) echo $lxout ;;
        10) mul -s$scale_lx $lxout 0.434294481903251 ;; # 2.302585092994045
        2) mul -s$scale_lx $lxout 1.442695040888862 ;; # 0.693147180559994   #3.32192809489 
    esac
} ## logx
# scale_lx= base= x= mask= frac= e_scale= rank= lxE= its= d= z= x_m= x_p= 
# ratio= total= lxcnt= dvsr_series= acu= sub_total= lxout=

# exp - e^x - Eulers' number 'e' raised to 'x'
# depends on: 'exp_z' 'tsst' 'add' 'mul
# precision is tuned to provide ~12 places for a wide range of inputs,
# where X<19 -tested down to ~X>0.00000002
exp_help() {
echo "    'exp' usage: 'exp [-s?] num1'
    'e^x' - raises Euler's number 'e' to a given power 'x' (e^x),
    Example usage: 'exp -s15 3.6' returns: '36.598234443677978'
    Example usage: 'exp -s8 1.134' returns: '3.10806392'
    Accurate to ~12 places where X<19.0."
}
exp() { escale=$defprec
    case $1 in -s*) escale=${1#*-s} ; shift ;; ''|-h) exp_help >&2 ; return 1 ;;esac
    case $1 in '') exp_help >&2 ; return 1 ;; *) expx=$1 ;;esac
    expneg=''
    case $expx in '-'*) expneg='-'  expx=${expx#*-} ;;esac
    e2scale=$((escale+2))
    # ln(10) = 2.302585092994045684 017991454684
    ln10=2.30258509299404568401
    # using limits of 1.1 gives us ~12 places of precision
    if tsst $expx -gt 1.1 ; then
        pad='1'
        while tsst $expx -gt 1.1 ; do
            expx=$( add $expx - $ln10 ) 
            pad=$pad'0'
        done
        expout=$( exp_z -s$e2scale $expx )
        expout=$( mul -s$escale $expout $pad )
        case $expneg in '-') div -s$escale 1 / $expout ;; *) echo $expout ;; esac
        
        # first draft was maybe a little easier to understand:
            #tsst $expx -gt 2.0
            #expn=0
            #while tsst $expx -gt 1.2 ; do
            #    expx=$( add $expx - $ln10 ) expn=$((expn+1))
            #done
            #expout=$( exp_z -s$e2scale $expx )
            #while [ $expn -gt 1 ] ; do
            #    expout=$( mul -s$e2scale $expout 10 ) expn=$((expn-1))
            #done
            #mul -s$escale $expout 10
    else
        expout=$( exp_z -s$e2scale $expx )
        case $expneg in '-') div -s$escale 1 / $expout ;; *) echo $expout ;; esac
    fi
} ## exp

### Back-end functions for pow nroot log
# fpow is used by: nrt_solv
# depends on: 'mul' 
# Don't call this directly unless you know how to use it
fpow() { case $1 in -s*) fstprec=${1#*-s} ; shift ;; *) fstprec=$defprec ;;esac
    case $1 in -t*) truncprec=${1#*-t} ; shift ;; *) truncprec='' ;;esac
    base_fst=$1
    case $2 in 0) echo 1.0 ; return ;; 1) echo $base_fst ; return ;;
        2) mul -s$fstprec $base_fst $base_fst  ; return ;;
    esac
    out_fst=$1
    exp_fst=$(( $2 - 1 ))
    
    while : ; do
        [ $((exp_fst%2)) -ne 0 ] && out_fst=$( mul -s$fstprec $out_fst $base_fst )
        exp_fst=$((exp_fst/2))
        [ $exp_fst -eq 0 ] && break
        base_fst=$( mul -s$fstprec $base_fst $base_fst )
    done
    
    case $truncprec in '') echo $out_fst;;
        *) case $out_fst in *.*) fstfrac=${out_fst#*.} 
            while [ ${#fstfrac} -gt $truncprec ] ; do fstfrac=${fstfrac%?*} ; done
            echo ${out_fst%.*}'.'$fstfrac ;;
            *) echo $out_fst ;;esac ;;
    esac
} ## fpow
# fstprec= base_fst= exp_fst= out_fst=

# nrt_solv -backend root solver for 'nroot'
# depends on: 'cmp3w' 'fpow' 'tsst'
# Don't call this directly unless you know how to use it
nrt_solv() { case $1 in -s*) nthrtsprec=${1#*-s} ; shift ;; *) nthrtsprec=$defprec ;;esac
    goal=$1 goal_int=${1%.*} goal_nth=$2
    # get the integer part of the answer
    answ_int='' this_nth=5 
    if [ "${goal_int:-0}" = 0 ] ; then
        answ_int=0
    else
        case $goal_int in 1|2|3) answ_int=1 answ_size=1 ;;
                *) while : ;do    # get size of answers' integer and pad-up columns if needed
                        case $( cmp3w "$( fpow -s0 '1'"$col" $goal_nth )" $goal_int ) in
                            '>') answ_size=${#col} col=${col%?*} ; break ;;esac
                        col=$col'0'
                    done ; answ_int='' ;;
        esac
        # search order for integer part: 5,9,7 - 5,1,3
        while : ;do
            this_product=$( fpow -s0 "$answ_int""$this_nth""$col" $goal_nth )
            signal=$( cmp3w $this_product $goal_int )
            [ $signal = "=" ] && { answ_int="$answ_int""$this_nth""$col" ; break ;}
            case $this_nth in
            '9') case $signal in '<') answ_int=$answ_int'9' this_nth=5 col=${col%?*} ;; '>') this_nth=7 ;;esac ;;
            '8') case $signal in '<') answ_int=$answ_int'8' this_nth=5 col=${col%?*} ;;
                                '>') answ_int=$answ_int'7' this_nth=5 col=${col%?*} ;;esac ;;
            '7') case $signal in '<') this_nth=8 ;; '>') this_nth=6 ;;esac ;;
            '6') case $signal in '<') answ_int=$answ_int'6' this_nth=5 col=${col%?*} ;; 
                                '>') answ_int=$answ_int'5' this_nth=5 col=${col%?*} ;;esac ;;
            '5') case $signal in '<') this_nth=9 ;; '>') this_nth=1 ;;esac ;;
            '4') case $signal in '<') answ_int=$answ_int'4' this_nth=5 col=${col%?*} ;;
                                '>') answ_int=$answ_int'3' this_nth=5 col=${col%?*} ;;esac ;;
            '3') case $signal in '>') this_nth=2 ;; '<') this_nth=4  ;;esac ;;
            '2') case $signal in '>') answ_int=$answ_int'1' this_nth=5 col=${col%?*} ;; 
                                '<') answ_int=$answ_int'2' this_nth=5 col=${col%?*} ;;esac ;;
            '1') case $signal in '>') answ_int=$answ_int'0' this_nth=5 col=${col%?*} ;; '<') this_nth=3 ;;esac ;;
            esac
            [ ${#answ_int} -eq $answ_size ] && break
        done
        # early exit if we already have the answer
        if tsst $this_product -eq $goal ; then
            case $nthrtsprec in 0) echo ${answ_int%.*} ;; *)  echo "${answ_int%.*}"".0" ;;esac
            return
        fi
    fi
    # do the fractional part
    answ_frac=''  answ_int=$answ_int'.' 
    # set a conservative scale for fpow to assure valid results
    fpow_scale=$(( (nthrtsprec * 18) / 10 ))
    this_nth=5 nthrtrunc=$((nthrtsprec+1))
    # Search order for fractional parts is: 5,9,7  5,3,1(was 5,1,3)
    while : ;do
        this_product=$( fpow -s$fpow_scale -t$nthrtrunc "$answ_int""$answ_frac""$this_nth" $goal_nth )
        signal=$( cmp3w $this_product $goal ) 
        [ $signal = "=" ] && { answ_frac="$answ_frac""$this_nth" ; break ;}
        case $this_nth in
            '1') case $signal in '<') this_nth=2 ;; '>') answ_frac=$answ_frac'0' this_nth=5 ;;esac ;;
            '2') case $signal in '<') answ_frac=$answ_frac'2' this_nth=5 ;; '>') answ_frac=$answ_frac'1' this_nth=5 ;;esac ;;
            '3') case $signal in '<') this_nth=4 ;; '>') this_nth=1 ;;esac ;;
            '4') case $signal in '<') answ_frac=$answ_frac'4' this_nth=5 ;; '>') answ_frac=$answ_frac'3' this_nth=5 ;;esac ;;
            '5') case $signal in '<') this_nth=9 ;; '>') this_nth=3 ;;esac ;;
            '6') case $signal in '<') answ_frac=$answ_frac'6' this_nth=5 ;; '>') answ_frac=$answ_frac'5' this_nth=5 ;;esac ;;
            '7') case $signal in '<') this_nth=8 ;; '>') this_nth=6 ;;esac ;;
            '8') case $signal in '<') answ_frac=$answ_frac'8' this_nth=5 ;; '>') answ_frac=$answ_frac'7' this_nth=5 ;;esac ;;
            '9') case $signal in '<') answ_frac=$answ_frac'9' this_nth=5 ;; '>') this_nth=7 ;;esac ;;
        esac
        [ ${#answ_frac} -eq $nthrtsprec ] && break 
    done
    # format output as needed
    case $nthrtsprec in 0) echo ${answ_int%.*} ;;
        *)  while [ ${#answ_frac} -gt $nthrtsprec ] ;do answ_frac=${answ_frac%?*} ;done
            echo ${answ_int%.*}'.'$answ_frac ;;
    esac
} ## nrt_solv
# nthrtsprec= goal_nth= goal= goal_int= answ_int= col= answ_size= this_nth= this_product= signal= answ_frac= nthrtrunc=

# smplfy - backend function used by pow
# depends on: 'div'
# used by 'pow'
smplfy() { 
    case $1 in *?.*) echo "->smplfy: Only fractions allowed" >&2 ; return 1 ;; 
        .?*) Nom=${1#*.} ;; *) Nom=${1} ;;
    esac
    scale_sf=${2:-$defprec}
    while : ;do case $Nom in *'0') Nom=${Nom%?*} ;; *) break ;;esac ;done # strip any trailing zeros
    Denom_size=$(( ${#Nom} + 1 ))  Denom=1
    while [ ${#Denom} -lt $Denom_size ] ; do Denom=$Denom'0' ; done
    # if there are leading zeros in the frac, strip them from front while stripping back of Denom
    while : ;do case $Nom in '0'*) Nom=${Nom#*?} Denom=${Denom%?*} ;; *) break ;;esac ;done
    if [ $Denom_size -lt 19 ] ; then
        for sim_try in 8 5 4 2 ;do
            if [ $(( $Nom % $sim_try )) -eq 0 ] && [  $(( $Denom % $sim_try )) -eq 0 ] ; then
                Nom=$(( $Nom / $sim_try )) ; Denom=$(( $Denom / $sim_try ))
            fi
        done
    else
        for sim_try in 25 16 8 5 4 2 ;do
            N_test_sf=$( div -s0 $Nom % $sim_try)
            D_test_sf=$( div -s0 $Denom % $sim_try )
            if [ "$N_test_sf" = '0' ] && [ "$D_test_sf" = '0' ] ; then
                 Nom=$( div -s$scale_sf $Nom / $sim_try ) Denom=$( div -s$scale_sf $Denom / $sim_try )
            fi
        done
    fi
    echo $Nom/$Denom
} ## smplfy
# scale_sf= Nom= Nom_size= Denom= sim_try= N_test_sf= D_test_sf=

# getE - returns scaled Eulers number 'e'
# used by: 'logx'
# 'getE n' returns 'e' to any precision up to 30 places
#  'getE' alone returns 'e' to 11 places
getE(){ case $1 in ?*) ecnt=-2 eout='' dummy=$EE
        while [ $ecnt -lt $1 ] ;do emsk=${dummy#*?} eout=$eout${dummy%$emsk*} dummy=$emsk ecnt=$((ecnt+1)) ;done
        echo $eout ;; *) echo $ee ;;esac
} ## getE
# ecnt= eout= dummy= emsk=

# e^x - an adaptation of the brilliant Pade approximation of e^x found here:
# Xeda112358 on https://www.omnimaga.org/math-and-science/pade-expansions-for-approximating-the-exponential-function/
## y=x^2
## a=( (x/2) * ( 1 + (5y/156)*( 1 + (3y/550)*( 1 + (y/1512))  )  /  ( 1 + (3y/26)*( 1 + (5y/396)*( 1 + (y/450))
## e^x = (1+a)/(1-a)
# as X gets smaller accuracy increases dramatically (tested to; x=0.00000002 ~80 places)
# for x>1.4(12 places) x must be reduced
# operations: 10X mult, 9X div, 8X add
# depends on: 'add' 'mul' 'div'
exp_z() { escale=$defprec
    case $1 in -s*) escale=${1#*-s} ; shift ;; ''|-h) exp_help >&2 ; return 1 ;;esac
    e2scale=$((escale+1))
    expx=$1
    # y = x^2
    y=$( mul -s$e2scale $expx $expx )
    # halfx = x/2
    halfx=$( div -s$e2scale $expx / 2 )
    
    #nom=( 1 + (5y/156)*( 1 + (3y/550)*( 1 + (y/1512)) )
    A=$( div -s$e2scale "$(mul 5 $y)" / 156 )
    B=$( div -s$e2scale "$(mul 3 $y)" / 550 )
    C=$( div -s$e2scale $y / 1512 )
    nom=$( add 1 + $C )
    nom=$( mul -s$e2scale $nom $B)
    nom=$( add 1 + $nom )
    nom=$( mul -s$e2scale $nom $A)
    nom=$( add 1 + $nom )
    
    #denom = ( 1 + (3y/26)*( 1 + (5y/396)*( 1 + (y/450))
    X=$( div -s$e2scale "$(mul 3 $y)" / 26 )
    Y=$( div -s$e2scale "$(mul 5 $y)" / 396 )
    Z=$( div -s$e2scale $y / 450 )
    denom=$( add 1 + $Z )
    denom=$( mul -s$e2scale $denom $Y)
    denom=$( add 1 + $denom )
    denom=$( mul -s$e2scale $denom $X)
    denom=$( add 1 + $denom )
    
    # first general ratio
    ratio1=$( div -s$e2scale $nom / $denom )
    # (x/2) * ratio1
    A=$( mul -s$e2scale $ratio1 $halfx )
    
    # e^x = (1+a)/(1-a)
    nom=$( add 1  + $A )
    denom=$( add 1 - $A )
    div -s$escale $nom / $denom
} ## exp_z

### End back-end functions for pow nroot logx exp

### Miscellaneous functions currently unused elsewhere
# factorial - returns the factorial of an integer input
# depends on: 'mul'
# Example usage: 'factorial 5' returns: '120'
factorial(){ case $1 in -s*) shift ;;esac
    case $1 in *.*) echo "factorial: Only integer inputs are allowed." >&2 ; return 1 ;;esac
    fact_out=$1 fact=$((fact_out-1))
    while [ $fact -gt 1 ] ;do fact_out=$( mul -s0 $fact_out x $fact ) fact=$((fact-1)) ; done
    echo $fact_out
} ## factorial  # fact_out= fact=

# gcf - find the Greatest Common Factor of two integer numbers
# depends on: 'div' 'mul' 'add'
gcf() {  case $1 in -s*) shift ;;esac   # scale is unused
    case $1 in *.*) echo "gcf: Only integer inputs allowed" >&2 ; return 1 ;;esac
    case $2 in *.*) echo "gcf: Only integer inputs allowed" >&2 ; return 1 ;;esac
    gcf_n1=$1 gcf_n2=$2
    while [ $gcf_n2 -ne 0 ] ; do
        gcf_q=$( div -s0 $gcf_n1 / $gcf_n2 )
        gcf_pp=$( mul -s0 $gcf_q x $gcf_n2 )
        gcf_new2=$( add -s0 $gcf_n1 - $gcf_pp )
        gcf_n1=$gcf_n2  gcf_n2=$gcf_new2
    done
    echo $gcf_n1
} ## gcf  # gcf_n1= gcf_n2= gcf_q= gcf_p= gcf_pp= gcf_new2

# 'getP n' returns 'pi' to any precision up to 30 places -as 'getP 12' for 12 places
# 'getP' alone returns 'pi' to 11 places
getP(){ case $1 in ?*) pcnt=-2 pout='' dummy=$PI
        while [ $pcnt -lt $1 ] ;do pmsk=${dummy#*?} pout=$pout${dummy%$pmsk*} dummy=$pmsk pcnt=$((pcnt+1)) ;done
        echo $pout ;; *) echo $pi ;;esac
} ## getP
# pcnt= pout= dummy= pmsk=

# 'getPhi n' returns 'phi' to any precision up to 30 places -as 'getPhi 12' for 12 places
# 'getPhi' alone returns 'phi' to 11 places
getPhi(){ case $1 in ?*) pcnt=-2 pout='' dummy=$PHI
        while [ $pcnt -lt $1 ] ;do pmsk=${dummy#*?} pout=$pout${dummy%$pmsk*} dummy=$pmsk pcnt=$((pcnt+1)) ;done
        echo $pout ;; *) echo $phi ;;esac
} ## getPhi
# pcnt= pout= dummy= pmsk=

### End Miscellaneous functions

iqXhelp() {
echo "      IQ+/iq+ - Version:$iqversion - Copyright 2021 Gilbert Ashley
    
    iq+ is an extension of the 'iq' calculator, with these functions:
    Public functions: pow ipow epow logx nroot exp
    Solutions are given as Real Numbers in the Cartesian Plane.
    For help on each function, call it with no arguments or '-h':
    Example: 'iq+ logx -h' or simply 'iq+ logx'
    
    iq+ should be used only after understanding the usage and syntax of 'iq'.
    From the CLI, iq enforces sane inputs, iq+ does not -so GIGO rules apply.
    For more on general iq/iq+ syntax and usage, run the function 'iqhelp'.
    When calling 'add' or 'mul' from iq+, the operators(+-x) are not required
    and operations can be performed on a series of inputs: 'add 3 7 22.5 -4.1'
    
    The utility functions 'factorial' and 'gcf' have no help section.
    See the comments throughout the code and at the bottom, for detailed
    information on any function and how to use iq/iq+.
    
    iq/iq+ is tested under these shells: bash zsh posh dash ksh
    If speed is a concern, try a shell further right in the list.
    "
}

# If 'iq' and 'iq+' are in your PATH use: 'iq+ command'
# Or temporarily add the location of 'iq' to your PATH, like this:
# PATH=path_to_iq:$PATH iq add 23.43578 7234.45
# Otherwise, 'iq' and 'iq+' must be in the users' current working
# directory and you'd then call iq+ like this: './iq+ command'
case "${0##*/}" in iq+*) 
    # we don't get here if this file has been sourced: '. this_file'
    # iq+ needs to source iq for the main functions
    # for debugging, also handle filenames that have a version number 
    case $0 in 
        ./iq+) src=1 . ./iq;;
        ./iq+?*) vers=${0#*'+'} ; src=1 . ./iq$vers ;; 
        *iq+) src=1 . iq ;;
        *iq+?*) vers=${0#*'+'} ; src=1 . iq$vers ;; 
    esac
    #cmd=$1 ; shift
    # since we are going to do '$cmd "$@"' below, make sure that only our functions
    # can be called, by eliminating the PATH and catching absolute/relative paths
    PATH=
    case $1 in '') iqXhelp >&2 ; exit ;;
        */*) echo "$0: Improper or dangerous input(a path or command): '$1'" ; exit 1 ;;
    esac
    # this the only place iq+ ever executes something and should only
    # recognize its' own functions. In the functions, command-sustitution is
    # used extensively, but only to run other iq/iq+ functions.
    cmd=$1 ; shift
    $cmd "$@" 
    exit $? # exit status for command-line use like: 'iq+ tsst 1111 -gt 1110 && echo greater'
   ;;
esac
# end of code

# If you want to use these functions and the normal functions from iq in 
# other shell scripts, simply put these lines into your script like this -without the quotes:
# 'src=1 . ./iq'   -or, as above: 'src=1 . iq'
# 'src=1 . ./iq'   -or, as above: 'src=1 . iq+'
# Or, just source 'iq' and copy the functions you need from iq+ into the body of your script.
# See 'example1.sh' for an example of including functions from 'iq' and 'iq+', etc in your script.

# For more complete instructions, see the bottom lines of 'iq' itself

