#!/bin/sh
# IQ+/iq+ - Extended version of the iq4sh/iq calculator

# Copyright Gilbert Ashley 29 January 2022
# Contact: OldGringo9876@gmx.de  Subject-line: IQ4sh

# Public functions: pow, nroot, logx, exp, sin, cos, tan, ipow, epow
# Back-end functions: fpow, nrt_solv, exp_z, getConst, dgrs2rdns, sin14, cos14
# Miscellaneous functions: factorial, gcf, dec2frac, rdns2dgrs

# dgrs2rdns, rdns2dgrs - raise scale of factors from 12 to 20
# sin, cos, tan - use twin approximations to increase accuracy
# from 6 places to ~12-14 places
# sin14 cos14 - new backend functions for sin cos

# disable some style checks and un-helpful suggestions
# shellcheck disable=SC2034,SC2086,SC2295,SC2004,SC1090,SC1091,SC2123

iqplusversion=1.76

# default precision 
defprec=${defprec:-5}

# pow - raises a decimal number to a given power (3.14 ^-4.12)
# depends on: 'logx' 'exp' 'ipow' 'epow' 'mul' 'div'
pow_help() {
echo "   'pow' usage: 'pow [-s?] base [^] exponent'
    
    Example: 'pow -s9 3.141592 ^ 6' = 961.387993507
    Example: 'pow -s12 12.141592 ^ -6' = 0.000000312137
    
    Decimal exponents are supported, if 'base' < 4.0
    Example: 'pow -s11 3.14 ^ -4.123558' = 0.00893062336
    Accuracy is ~11 places but increases as 'base' nears zero
    Example: 'pow -s15 0.618 ^ 7.385' = 0.028605522741231
    " 
}
pow() { scale_pow=$defprec
    case $1 in -s*) scale_pow=${1#*-s} ; shift ;; ''|-h) pow_help >&2 ; return 1 ;;esac
    pbase=$1 ; shift ; case $1 in '^') shift ;;esac
    case $1 in '') pow_help >&2 ; return 1 ;;esac
    pexp=$1 pexpneg='' pbaseneg=''
    # separate and remove neg signs
    case $pbase in '-'*) pbaseneg='-' pbase=${pbase#*?} ;;esac
    case $pexp in '-'*) pexpneg='-' pexp=${pexp#?*} ;;esac
    # separate integer and fractional parts
    case $pbase in .?*) pbase_int=0 pbasefrac=${pbase#*.} ;; *?.?*) pbase_int=${pbase%.*} pbasefrac=${pbase#*.} ;;
        *) pbase_int=$pbase pbasefrac=0 ;;esac
    case $pexp in .?*) pexp_int=0 pexpfrac=${pexp#*.} ;; *?.?*) pexp_int=${pexp%.*} pexpfrac=${pexp#*.} ;;
        *) pexp_int=$pexp pexpfrac=0 ;;esac
    # remove extra leading zeros from integers
    while : ;do case $pbase_int in '0'?*) pbase_int=${pbase_int#?*} ;; *) break ;;esac ;done
    while : ;do case $pexp_int in '0'?*) pexp_int=${pexp_int#?*} ;; *) break ;;esac ;done
    # remove extra trailing zeros from fractions
    while : ;do case $pbasefrac in *?'0') pbasefrac=${pbasefrac%?*} ;; *) break ;;esac ;done
    while : ;do case $pexpfrac in *?'0') pexpfrac=${pexpfrac%?*} ;; *) break ;;esac ;done
    # recombine
    pbase=$pbase_int'.'$pbasefrac  pexp=$pexp_int'.'$pexpfrac
    case "$pbaseneg""$pbase" in
        0.0) case "$pexpneg""$pexp" in -*) echo "-->pow: NaN" >&2 ; return 1 ;;  
                0.0) echo 1.0 ; return ;; *) echo 0.0 ; return ;;esac ;;
        1.0) echo 1.0 ; return ;;
        -*) [ "$pexpfrac" != 0 ] && { echo "-->pow: NaN" >&2 ; return 1 ;}
            [ $((pexp_int%2)) -eq 0 ] && pbaseneg='' ;;
    esac
    case "$pexpneg""$pexp" in
        0.0) echo 0.0 ; return ;; 1.0) echo $pbaseneg$pbase ; return ;;
        -1.0) div -s$scale_pow  1 / $pbaseneg$pbase ; return ;;
    esac
    
    case $pexpfrac in 
        0)  # if exponent is integer, use ipow/epow
            case $pexp_int in 
                1) pres=$pbase_int'.'$pbasefrac ;; # cant get here
                2) pres=$( mul -s$scale_pow $pbase_int'.'$pbasefrac  $pbase_int'.'$pbasefrac ) ;;
                *) pres=$( ipow -s$scale_pow $pbase_int'.'$pbasefrac $pexp_int ) ;;
            esac
        ;; 
        *)  # if exponent is non-integer and base<4 use e^x method
            # a^x = e^(x(ln(a))
            if [ $pbase_int -lt 4 ] ; then
                pmed_scale=$((scale_pow+3+pbase_int))
                plog=$( logx -s$pmed_scale n $pbase )
                pprod=$( mul -s$pmed_scale $pexp $plog )
                pres=$( exp -s$((scale_pow+2)) $pprod )
            else
                # for base>4, we could use a long, slow, real calculation
                # but it's simply too slow when running under 'bash' or 'zsh'
                # if you have ksh, dash or all the time in the world,
                # you could try commenting the folowing 2 lines...
                echo "-->pow: base '$pbase_int.$pbasefrac' out of range" >&2 
                pow_help >&2 ; return 1
                # additionally depends on: nroot
                
                # truncate exponent fraction to max 2 places
                case $pexpfrac in 
                    ?) nom=$pexpfrac ;; *) nom=${pexpfrac%"${pexpfrac#*??}"*} ;;
                esac
                # establish and reduce the arguments to nroot
                denom=100 
                case $nom in 
                    ?1|?3|?7|?9) case $nom in 0*) nom=${nom#*?} ;; esac ;; 
                    1|3|7|9) denom=10 ;; 5) nom=1 denom=2 ;; ?) denom=5 nom=$((nom/2)) ;;
                    *)  case $nom in 0*) nom=${nom#*?} ;; esac
                        for simpl in 8 5 4 2 5 4 2 ;do
                            if [ $(( $nom % $simpl )) -eq 0 ] && [  $(( $denom % $simpl )) -eq 0 ] ; then
                                nom=$(( $nom / $simpl )) ; denom=$(( $denom / $simpl ))
                            fi
                        done 
                    ;;
                esac
                # use a generous intermediate scale
                pmed_scale=$((scale_pow * 2))
                # get the result of the exponent integer
                pres=$( ipow -s$pmed_scale $pbase_int'.'$pbasefrac $pexp_int )
                
                # calculate the root, then the power
                case $nom in
                    1)  nth_root=$( nroot -s$pmed_scale $pbase_int.$pbasefrac $denom )
                        pres=$( mul -s$pmed_scale $pres $nth_root ) ;;
                    *)  nth_root=$( nroot -s$pmed_scale $pbase_int.$pbasefrac $denom )
                        nth=$( ipow -s$pmed_scale $nth_root $nom )
                        pres=$( mul -s$pmed_scale $pres $nth ) 
                        ;;
                esac
            fi
        ;;
    esac
    
    # if the exponent is negative, invert the result
    case $pexpneg in '-') pres=$( div -s$scale_pow 1 / $pres ) ;;esac
    # truncate or trim to scale
    case $scale_pow in 0) echo $pbaseneg${pres%.*} ;; *) pfrac=${pres#*.} 
        while [ ${#pfrac} -gt $scale_pow ] ;do pfrac=${pfrac%?*} ;done
        echo $pbaseneg${pres%.*}'.'${pfrac:-0} ;; 
    esac
    #pbaseneg='' pexpneg=''

} ## pow
# scale_pow= pbase= pexp= pbaseneg= pexpneg= pbase_int= pbasefrac= i_scale= pmed_scale=
# pres= simple_frac nom= denom= nth_root= nth= pfrac=

# ipow - raises a decimal number to an integer power
# depends on: 'epow' 'logx' 'mul' 'div'
ipow_help() {
echo "   'ipow' usage: 'ipow [-s?] base [^] exponent'
    
    'base' must be a positive number, integer or decimal.
    Exponents can be negative or positive, but must be integers.
    Example: 'ipow -s20 3.14 ^ -4' = 0.01028682632761480208
    Example: 'ipow -s9  9.35234 16' = 3425504893420641.057301958
    "
}
ipow(){ mp_prec=$defprec
    case $1 in -s*) mp_prec=${1#*-s} ; shift ;; ''|-h) ipow_help >&2 ; return 1 ;;  esac
    basemp=$1 ; shift ; case $1 in '^') shift ;;esac
    case $basemp in '-'*) echo "-->ipow: negative bases not supported: $basemp" >&2 ; return 1 ;;esac
    case $1 in '') ipow_help >&2 ; return 1 ;; 
        *.*) echo "-->ipow: fractional exponents not supported: $1" >&2 ; return 1 ;;
        *) expmp=$1 ;;
    esac
    # store any negation of exponent
    case $expmp in '-'*) expmpneg='-' expmp=${expmp##*-}  ;;esac
    case $basemp in 
        0.*|.*) out_mp=$( epow -S$mp_prec $basemp $expmp )
                case $expmpneg in '-') div -s$mp_prec 1 / $out_mp ;; *) echo $out_mp ;;esac
                return ;;    # use epow for bases less than 1
        *.*) 
            # (log10(base) * exp) + 1 = integer size of result
            logmp=$(logx -s7 10 $basemp)
            mpint_size=$(( $(mul -s0 $logmp $expmp) + 1 ))
            # a reliable minimum scale
            mpmin=$(( ( $expmp + $mpint_size) / 2))
            # plus the requested scale -use a minimum of 5
            [ $mp_prec -lt 5 ] && rec_scale=$(( $mpmin + 5 )) || rec_scale=$(( $mpmin + $mp_prec ))
        ;;
        *) rec_scale=0 mp_prec=0 ;; # for integer bases, we can skip the expensive stuff above
    esac
    # do the operation
    out_mp=$basemp
    expmp=$((expmp-1))
    while : ; do
        [ $((expmp%2)) -ne 0 ] && out_mp=$( mul -s$rec_scale $out_mp $basemp ) 
        expmp=$((expmp/2))
        [ $expmp -eq 0 ] && break
        basemp=$( mul -s$rec_scale $basemp $basemp )
    done
    # negative exponent
    case $expmpneg in '-'*) out_mp=$( div -s$mp_prec 1 / $out_mp ) ;;esac
    # format the output
    case $mp_prec in 0) echo ${out_mp%.*} ;;
        *)  out_frac_mp=${out_mp#*.}
            while [ ${#out_frac_mp} -gt $mp_prec ] ; do 
                out_frac_mp=${out_frac_mp%?*}
            done
            echo ${out_mp%.*}'.'$out_frac_mp ;;
    esac
} ## ipow
# mp_prec= basemp= expmp= basemp_frac= maxmp= logmp= mpint_size= 
# mpmin= gr= rec_scale= out_mp= out_frac_mp=

# epow - pow function with answers in normal scale, SigFig scale or e-notation
# depends on: 'logx' 'mul'
# used by: 'ipow' for bases X<1
# example: epow -e6 0.0105 ^ 1000000000 = 1.174730e-1978810701 
epow_help()  {
echo "    'epow' usage: 'epow [-s?,-S,-e?] base [^] exponent' 
    
    Both 'base' and 'exponent' must be positive numbers.
    'base' can be an integer or decimal, 'exponent' must be integer.
    'epow' returns powers with answers in three forms: normally
    scaled outputs, significant digits or scientific notation.
    Output format is controlled with 3 scaling options: -s? -S? or -e?
    
    Example usage for normal scaling: 'epow -s9 0.14 7' = 0.000001054
    Example for significant digits: 'epow -S9 0.14 7' = 0.00000105413504
    Example for scientific notation: 'epow -e9 0.14 7' = 1.05413504e-6
    Example for scientific notation: 'epow -e12 42.818 7' = 2.638667359224e11
    "
}
epow() { fstprec=$defprec   # normal scaling             # sigfig scaling
    case $1 in -s*) fstprec=${1#*-s} ; shift ;; -S*) fstprec=${1#*-S}  SigScale=1 ; shift ;;
            # e-notation scaling       
        -e*) fstprec=${1#*-e} E_note=1 ; shift ;; ''|-h) epow_help >&2 ; return 1 ;;
    esac
    SigScale=${SigScale:-0} E_note=${E_note:-0}
    base=$1 ; shift ; case $1 in '^') shift ;;esac
    #case $base in '-'*) epowneg='-'  base=${base#*-} ;;esac
    case $base in '-'*) echo "-->epow: negative base not supported: $basemp" >&2 ; return 1 ;;esac
    case $1 in '-'*) echo "-->epow: Use 'pow' for negative exponents" >&2 ; return 1 ;;
        *.*) echo "-->epow: fractional exponents not supported: $1" >&2 ; return 1 ;;
        '') epow_help >&2 ; return 1 ;;
        *) exp=$1 ;;
    esac
    
    case $E_note in 1) fst_scale=$((fstprec+8)) ;; *) fst_scale=$((exp+fstprec+3)) ;;esac
    # for low scales or exponents over 1,000,000 -we need a small booost...
    [ ${#exp} -gt 7 ] && fst_scale=$(( fst_scale + (${#exp}-7) ))
    [ $fstprec -lt 7 ] && fst_scale=$(( fst_scale + 2 ))
    case $base in 
        0.0*|.0*) zeros=0 dummy=${base#*.}  # remove and count leading zeros
            while : ; do case $dummy in 0*) dummy=${dummy#*?} zeros=$((zeros+1)) ;; *) break ;;esac ; done
            # take the log of the rest
            bplog=$(logx -s7 10 '.'$dummy )
            # multiply the absolute value of the log by the exponent to determine the length of growth
            E=$(mul -s0 ${bplog#*-} $exp )
            # add in the leading zeros, which are (zeros * exp) and add back the sign
            E=$((E + (zeros*exp) )) E='-'$E ;;
        0.*|.*)     # like above, but without leading zeros in the base
            bplog=$(logx -s7 10 $base ) E=$(mul -s0 ${bplog#*-} $exp ) E='-'$E ;;
            #bplog=$(logx -s10 10 $base ) E=$(mul -s0 ${bplog#*-} $exp ) E='-'$E ;;
        *)  # integers need a '0' fraction which is later removed
            bplog=$(logx -s7 10 $base ) E=$(mul -s0 $exp $bplog)
            case $base in 
                *.*) #base_int=${base%.*} base_int_size=${#base_int}
                    [ 0 = "$E_note" ] && fst_scale=$(( E + fstprec + 5 )) ;; 
                *) base=$base'.0' is_int=1 ;;
            esac
            base='.'${base%.*}${base#*.} ;;
    esac
    
    # do the operation -everything has been made into a fraction
    # keep only the significant digits after each multiplication
    out_pm=$base
    exp=$((exp - 1))
    while : ; do 
        if [ $((exp%2)) -ne 0 ] ; then
            out_pm=$( mul -s$fst_scale $out_pm $base ) 
            dummy=${out_pm#*.}
            while : ; do case $dummy in 0*) dummy=${dummy#*?} ;; *) break ;;esac ; done
            out_pm='0.'$dummy
        fi
        exp=$((exp/2))
        [ $exp -eq 0 ] && break
        base=$( mul -s$fst_scale $base $base )
        dummy=${base#*.}
        while : ; do case $dummy in 0*) dummy=${dummy#*?} ;; *) break ;;esac ; done
        base='0.'$dummy
    done
    
    # reconstruct the output
    if [ 1 = "$E_note" ] ; then
        case $E in -*) E=$((E-1)) ;;esac
        dummy=${out_pm#*.}  # remove the extra 8, unless fraction has terminated
        [ ${#dummy} -gt $fst_scale ] && dummy=${dummy%???????*}
        msk1=${dummy#*?} out_pm=${dummy%$msk1*}
        while [ ${#msk1} -gt $fstprec ] ; do msk1=${msk1%?*} ; done
        echo $out_pm'.'${msk1:-0}'e'$E
    else
        case $E in 
            -*) cnt_p=0 pad='' E_abs=${E#*-}
                while [ $cnt_p -lt $E_abs ] ; do pad=$pad'0' cnt_p=$((cnt_p+1)); done
                cnt_p=0 dummy=$pad${out_pm#*.} out_pm=''
                case $SigScale in 1) fstprec=$(( $E_abs + fstprec )) 
                        while [ ${#dummy} -gt $fstprec ] ; do dummy=${dummy%?*} ; done
                        out_pm=$dummy
                    ;;
                    *)  while [ $cnt_p -lt $fstprec ] ; do 
                            cnt_p=$((cnt_p+1)) msk1=${dummy#*?} out_pm=$out_pm${dummy%$msk1*} dummy=$msk1
                        done ;;
                esac
                out_pm='0.'$out_pm
            ;;
            *)  dummy=${out_pm#*.}  # trim off extra unless input was integer or fraction terminates at shorter length
                [ 1 != "$is_int" ] && [ ${#dummy} -gt $fst_scale ] && dummy=${dummy%???*}
                cnt_p=-1 out_pm=''
                while [ $cnt_p -lt $E ] ; do 
                    cnt_p=$((cnt_p+1)) msk1=${dummy#*?} out_pm=$out_pm${dummy%$msk1*} dummy=$msk1
                done
                cnt_p=0 zeros=0 out_frac=''
                case $SigScale in 1) scratch=$dummy
                    while : ; do case $scratch in 0*) zeros=$((zeros+1)) scratch=${scratch#*?} ;; *) break ;;esac ; done
                esac
                fstprec=$((fstprec+zeros))
                while [ $cnt_p -lt $fstprec ] ; do 
                    cnt_p=$((cnt_p+1)) msk1=${dummy#*?} out_frac=$out_frac${dummy%$msk1*} dummy=$msk1
                done
                out_pm=$out_pm'.'${out_frac:-0}
            ;;
        esac
        [ 1 = "$is_int" ] && echo ${out_pm%.*} || echo $out_pm
    fi
} ## epow
# fstprec= SigScale= E_note= base= exp= fst_scale= zeros= dummy= bplog= E= base_int= base_int_size= out_pm=
# msk1= cnt_p= scratch= out_frac

# nroot - find the 'n-th' root of a number
# depends on: 'nrt_solv' 'div'
nroot_help() {
echo "   'nroot' usage: 'nroot [-s?] Number Nth'
    
    'Number' must be a positive integer or decimal
    'Nth' must be a positive integer
    Example: 'nroot -s6 4.3 10' for: 10th root of 4.3
    Example: 'nroot -s8 43.225 2' for: sqrt of 43.225
    Example: 'nroot -s12 2 2' = 1.414213562373
    "
}
nroot() { scale_nrt=$defprec
    case $1 in -s*) scale_nrt=${1#*-s} ; shift ;; ''|-h) nroot_help >&2 ; return 1  ;;esac
    case $2 in '') nroot_help >&2 ; return 1  ;; 
        *.*) echo "-->nroot: Nth must be an integer" >&2 ; return 1 ;; 
    esac
    base_nrt=$1 N_th=$2 # get the inputs
    case $N_th in '-'*) Nth_neg='-' N_th=${N_th#*-} ;; esac # separate neg from nth
    while : ; do case $N_th in 0?*) N_th=${N_th#*?} ;; *) break ;; esac ; done # depad nth
    case $base_nrt in '-'*) nrt_neg='-' base_nrt=${base_nrt#*-} ;; esac # separate neg from base
    case $base_nrt in 0.*|.*) nrt_int=0 nrt_frac=${base_nrt#*.} ;; # separate base int and frac
        *.*) nrt_int=${base_nrt%.*} nrt_frac=${base_nrt#*.} ;; *) nrt_int=$base_nrt nrt_frac=0 ;;
    esac
    while : ; do case $nrt_int in 0?*) nrt_int=${nrt_int#*?} ;; *) break ;; esac ; done # depad base int
    while : ; do case $nrt_frac in *?0) nrt_frac=${nrt_frac%?*} ;; *) break ;; esac ; done # depad base frac
    base_nrt=$nrt_int'.'$nrt_frac
    # handle special cases
    case $nrt_neg$base_nrt in
        0.0) case "$Nth_neg""$N_th" in -*) echo "-->nroot: NaN" >&2 ; return 1 ;;  
                0) echo 1.0 ; return ;; *) echo 0.0 ; return ;;esac ;;
        1.0) echo 1.0 ; return ;;
        -*) [ $((N_th%2)) -eq 0 ] && { echo "-->nroot: NaN" >&2 ; return 1 ;} ;;
    esac
    case $Nth_neg$N_th in
        0) echo 0.0 ; return ;; 1) echo $nrt_neg$base_nrt ; return ;;
        -1) div -s$scale_nrt  1 / $nrt_neg$base_nrt ; return ;;
    esac
    # If we get here, do scale-compensation for small bases, or user requests scale=0
    if [ $scale_nrt -eq 0 ] ; then
        scale_nthrt=2
    else
        # a complete solution for bases <0.0?* would mean counting leading zeros, but let's try this
        case $base_nrt in 0.0*) scale_nthrt=$(( (scale_nrt*12) / 10 )) ;; *) scale_nthrt=$scale_nrt ;; esac
    fi
    # for Nth which are multiples of 10, break into chunks
    if [ $((N_th % 10)) -eq 0 ] ; then
        while [ $N_th -gt 9 ] ;do
            N_th=$((N_th / 10))
            base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt 10 )
        done
        [ $N_th -gt 1 ] && base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $N_th )
    else
        # otherwise use the longer method
        if [ $N_th -gt 9 ] ; then
            solved=0 # try using factors
            for try in 9 8 7 6 5 4 3 2 ;do
                if [ $((N_th % try)) -eq 0 ] ; then
                    N_th=$((N_th / try))
                    base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $try )
                    base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $N_th )
                    solved=1 ; break
                fi
            done
            # number is prime or its' smallest factor is >9
            [ 0 = "$solved" ] && base_nrt=$( nrt_solv -s$scale_nthrt $base_nrt $N_th )
        else
            # for small N_th
            base_nrt=$( nrt_solv -s$scale_nthrt $base_nrt $N_th )
        fi
    fi
    case $Nth_neg in '-') base_nrt=$( div -s$scale_nthrt 1 / $base_nrt ) ;; esac
    # messy(still) decomposition of intermediate scales and output
    case $scale_nthrt in "$scale_nrt") echo $nrt_neg$base_nrt ;; 
        *)  case $scale_nrt in 0) echo $nrt_neg${base_nrt%.*} ;;
                *)  nrt_frac=${base_nrt#*.} nrt_out_frac=
                    while [ ${#nrt_out_frac} -lt $scale_nrt ] ; do   
                        nrt_msk=${nrt_frac#*?} nrt_out_frac=$nrt_out_frac${nrt_frac%$nrt_msk*} nrt_frac=$nrt_msk
                    done
                    echo $nrt_neg${base_nrt%.*}'.'$nrt_out_frac ;;
            esac ;;
    esac
    
} ## nroot -s7 4.2 5 (for 5th root of 4.2)
# scale_nthrt= N_th= base_nrt= solved=

# logx - returns logarithms in base 10, e/n or 2
# depends on: 'getConst' 'tsst' 'mul' 'div' 'add'
# This uses a fast approximation with good precision to about 11 places
# asking for more digits will break the result, so don't be greedy
# uses a power series for ln(x) and then converts to base 2 or 10 if needed
# ln(x) = 2{ (x-1/x+1) + 1/3(x-1/x+1)^3 + 1/5(x-1/x+1)^5 + ...}
logx_help() {
echo "    'logx' usage: 'logx [-s?] base num1'
    
    Calculates logarithms to ~11 places
    Example: 'logx -s8 10 6.7' for: log(6.7)
    Example: 'logx -s7 n 6.7' for: ln(6.7)
    Example: 'logx -s7 2 6.7' for: log2(6.7)
   "
}
logx() { scale_lx=$defprec
    case $1 in -s*) scale_lx=${1#*-s} ; shift ;; ''|-h) logx_help >&2 ; return 1 ;;esac
    case $2 in '') logx_help >&2 ; return 1 ;;esac
    base=$1 x=$2 # special cases and errors
    case $x in # input errors and logx(1) are universal for all bases
        -*) echo "-->logx: NaN" >&2 ; return 1 ;;
        0|0.0) echo "-->logx: NaN" >&2 ; return 1 ;; 
        1|1.0) echo 0.0 ; return ;;
    esac
    case $base in # base-specific errors and easy-outs
        10) # log10 easy outs - different for other bases
            case $x in 
                0.1|.1) echo '-1' ; return ;; 10|10.0) echo 1 ; return ;; 10'.'*) : ;;
                10*)  mask=${x#?*} ; tsst $mask -eq 0 && { echo ${#mask}'.0' ; return ;} ;;
                .0*|0.0*) frac=${x#*.} # possible 10â»n, if so: 0.01, 0.001, ..., return -1, -2, ...
                    tsst ${frac%1*} -eq 0  && { echo '-'${#frac}'.0' ; return ;} ;;
            esac ;; 
        2|n|e) : ;;
        *) echo "-->logx: False base input: e, n, 2 or 10 allowed" >&2 ; return 1 ;;
    esac
    # set the internal scale, then determine the characteristic/rank
    e_scale=$(($scale_lx+2)) rank=0
    lxE=$(getConst e $e_scale)
    if tsst $x -lt 0.4 ; then
        case $x in  
            0.0*|.0*) while tsst $x -lt .4 ;do rank=$((rank-1)) x=$( mul -s$e_scale $x $lxE ) ;done ;;
            *) rank=-1 x=$( mul -s$e_scale $x $lxE ) ;;
        esac
    elif tsst $x -gt 2.8 ; then
        while tsst $x -gt 2.8 ;do rank=$((rank+1)) x=$( div -s$e_scale $x / $lxE ) ;done
    fi
    its=$((scale_lx+2))    # set the max number of iterations -using too many will ruin result
    case $x in 0.0*) echo "-->logx: how did we get here?" >&2 ; return 1 ;; # this happens when called incorrectly
        0.1*|0.2*) e_scale=$((scale_lx+6)) its=$(($scale_lx+6)) ;; 
        1.0*) d=${x#*.} z=0 ; while : ;do case $d in 0*) z=$((z+1)) d=${d#?*} ;; *) break ;;esac ;done
            e_scale=$((scale_lx+z+2)) ;;
    esac
    # get the initial ratio of (x-1/x+1) and initialize acu and total 
    x_m=$( add -s$e_scale $x - 1 )         x_p=$( add -s$e_scale $x + 1 )
    ratio=$( div -s$e_scale $x_m / $x_p )   total=$ratio acu=$ratio lxcnt=0 dvsr_series=3
    
    # do the iterations  (x-1/x+1)^3/3 ... (x-1/x+1)^5/5 ... (x-1/x+1)^7/7
    while [ $lxcnt -lt $its ] ;do
        acu=$( mul -s$e_scale $acu $ratio )    acu=$( mul -s$e_scale $acu $ratio )
        tsst ${acu#*-} -eq 0 && break
        sub_total=$( div -s$scale_lx $acu / $dvsr_series ) total=$( add $total $sub_total )
        lxcnt=$((lxcnt+1)) dvsr_series=$((dvsr_series+2))
    done
    lxout=$( mul -s$e_scale $total 2 )
    lxout=$( add -s$scale_lx $lxout $rank )
    # print or convert the output according to the base
    case $base in e|n) echo $lxout ;;
        10) mul -s$scale_lx $lxout 0.434294481903251 ;; # 2.302585092994045
        2) mul -s$scale_lx $lxout 1.442695040888862 ;; # 0.693147180559994
    esac
} ## logx
# scale_lx= base= x= mask= frac= e_scale= rank= lxE= its= d= z= x_m= x_p= 
# ratio= total= lxcnt= dvsr_series= acu= sub_total= lxout=

# exp - e^x - Eulers' number 'e' raised to 'x'
# depends on: 'exp_z' 'tsst' 'add' 'mul
# precision is tuned to provide ~12 places for a wide range of inputs,
# where X<19 -tested down to ~X>0.00000002
exp_help() {
echo "    'exp' usage: 'exp [-s?] exponent'
    
    'e^x' - raises Euler's number 'e' to a given power 'x' (e^x),
    Example: 'exp -s15 3.6' returns: '36.598234443677978'
    Example: 'exp -s8 1.134' returns: '3.10806392'
    Accurate to ~12 places where X<19.0
    "
}
exp() { escale=$defprec
    case $1 in -s*) escale=${1#*-s} ; shift ;; ''|-h) exp_help >&2 ; return 1 ;;esac
    case $1 in '') exp_help >&2 ; return 1 ;; *) expx=$1 ;;esac
    expneg=''
    case $expx in '-'*) expneg='-'  expx=${expx#*-} ;;esac
    e2scale=$((escale+2))
    # ln(10) = 2.30258509299404568401 7991454684
    ln10=2.30258509299404568401
    # using limits of 1.1 gives us ~12 places of precision
    if tsst $expx -gt 1.1 ; then
        pad='1'
        while tsst $expx -gt 1.1 ; do
            expx=$( add $expx - $ln10 ) 
            pad=$pad'0'
        done
        expout=$( exp_z -s$e2scale $expx )
        expout=$( mul -s$escale $expout $pad )
        case $expneg in '-') div -s$escale 1 / $expout ;; *) echo $expout ;; esac
        
        # first draft was maybe a little easier to read:
            # using 2.0 & 1.2 (instead of 1.1) raises range and lowers precision
            #tsst $expx -gt 2.0
            #expn=0
            #while tsst $expx -gt 1.2 ; do
            #    expx=$( add $expx - $ln10 ) expn=$((expn+1))
            #done
            #expout=$( exp_z -s$e2scale $expx )
            #while [ $expn -gt 1 ] ; do
            #    expout=$( mul -s$e2scale $expout 10 ) expn=$((expn-1))
            #done
            #mul -s$escale $expout 10
    else
        expout=$( exp_z -s$e2scale $expx )
        case $expneg in '-') div -s$escale 1 / $expout ;; *) echo $expout ;; esac
    fi
} ## exp

### Back-end functions for pow nroot log
# fpow is used by: nrt_solv
# depends on: 'mul' 
# Don't call this directly unless you know how to use it
fpow() { case $1 in -s*) fstprec=${1#*-s} ; shift ;; *) fstprec=$defprec ;;esac
    case $1 in -t*) truncprec=${1#*-t} ; shift ;; *) truncprec='' ;;esac
    base_fst=$1
    # these conditions shouldn't really happen here, but just in case:
    case $2 in 0) echo 1.0 ; return ;; 1) echo $base_fst ; return ;;
        2) mul -s$fstprec $base_fst $base_fst  ; return ;;
    esac
    
    out_fst=$1
    exp_fst=$(( $2 - 1 ))
    while : ; do
        [ $((exp_fst%2)) -ne 0 ] && out_fst=$( mul -s$fstprec $out_fst $base_fst )
        exp_fst=$((exp_fst/2))
        [ $exp_fst -eq 0 ] && break
        base_fst=$( mul -s$fstprec $base_fst $base_fst )
    done
    
    case $truncprec in '') echo $out_fst;;
        *) case $out_fst in *.*) fstfrac=${out_fst#*.} 
            while [ ${#fstfrac} -gt $truncprec ] ; do fstfrac=${fstfrac%?*} ; done
            echo ${out_fst%.*}'.'$fstfrac ;;
            *) echo $out_fst ;;esac ;;
    esac
} ## fpow
# fstprec= base_fst= exp_fst= out_fst=

# nrt_solv -backend root solver for 'nroot'
# depends on: 'cmp3w' 'fpow' 'tsst'
# Don't call this directly unless you know how to use it
nrt_solv() { case $1 in -s*) nthrtsprec=${1#*-s} ; shift ;; *) nthrtsprec=$defprec ;;esac
    goal=$1 goal_int=${1%.*} goal_nth=$2
    # get the integer part of the answer
    answ_int='' this_nth=5 
    if [ "${goal_int:-0}" = 0 ] ; then
        answ_int=0
    else
        case $goal_int in 1|2|3) answ_int=1 answ_size=1 ;;
                *) while : ;do    # get size of answers' integer and pad-up columns if needed
                        case $( cmp3w "$( fpow -s0 '1'"$col" $goal_nth )" $goal_int ) in
                            '>') answ_size=${#col} col=${col%?*} ; break ;;esac
                        col=$col'0'
                    done ; answ_int='' ;;
        esac
        # search order for integer part: 5,9,7 - 5,1,3
        while : ;do
            this_product=$( fpow -s0 "$answ_int""$this_nth""$col" $goal_nth )
            signal=$( cmp3w $this_product $goal_int )
            [ $signal = "=" ] && { answ_int="$answ_int""$this_nth""$col" ; break ;}
            case $this_nth in
            '9') case $signal in '<') answ_int=$answ_int'9' this_nth=5 col=${col%?*} ;; '>') this_nth=7 ;;esac ;;
            '8') case $signal in '<') answ_int=$answ_int'8' this_nth=5 col=${col%?*} ;;
                                '>') answ_int=$answ_int'7' this_nth=5 col=${col%?*} ;;esac ;;
            '7') case $signal in '<') this_nth=8 ;; '>') this_nth=6 ;;esac ;;
            '6') case $signal in '<') answ_int=$answ_int'6' this_nth=5 col=${col%?*} ;; 
                                '>') answ_int=$answ_int'5' this_nth=5 col=${col%?*} ;;esac ;;
            '5') case $signal in '<') this_nth=9 ;; '>') this_nth=1 ;;esac ;;
            '4') case $signal in '<') answ_int=$answ_int'4' this_nth=5 col=${col%?*} ;;
                                '>') answ_int=$answ_int'3' this_nth=5 col=${col%?*} ;;esac ;;
            '3') case $signal in '>') this_nth=2 ;; '<') this_nth=4  ;;esac ;;
            '2') case $signal in '>') answ_int=$answ_int'1' this_nth=5 col=${col%?*} ;; 
                                '<') answ_int=$answ_int'2' this_nth=5 col=${col%?*} ;;esac ;;
            '1') case $signal in '>') answ_int=$answ_int'0' this_nth=5 col=${col%?*} ;; '<') this_nth=3 ;;esac ;;
            esac
            [ ${#answ_int} -eq $answ_size ] && break
        done
        # early exit if we already have the answer
        if tsst $this_product -eq $goal ; then
            case $nthrtsprec in 0) echo ${answ_int%.*} ;; *)  echo "${answ_int%.*}"".0" ;;esac
            return
        fi
    fi
    # do the fractional part
    answ_frac=''  answ_int=$answ_int'.' 
    # set a conservative scale for fpow to assure valid results
    fpow_scale=$(( (nthrtsprec * 13) / 10 ))
    this_nth=5 nthrtrunc=$((nthrtsprec+1))
    # Search order for fractional parts is: 5,9,7  5,3,1(was 5,1,3)
    while : ;do
        this_product=$( fpow -s$fpow_scale -t$nthrtrunc "$answ_int""$answ_frac""$this_nth" $goal_nth )
        signal=$( cmp3w $this_product $goal ) 
        [ $signal = "=" ] && { answ_frac="$answ_frac""$this_nth" ; break ;}
        case $this_nth in
            '1') case $signal in '<') this_nth=2 ;; '>') answ_frac=$answ_frac'0' this_nth=5 ;;esac ;;
            '2') case $signal in '<') answ_frac=$answ_frac'2' this_nth=5 ;; '>') answ_frac=$answ_frac'1' this_nth=5 ;;esac ;;
            '3') case $signal in '<') this_nth=4 ;; '>') this_nth=1 ;;esac ;;
            '4') case $signal in '<') answ_frac=$answ_frac'4' this_nth=5 ;; '>') answ_frac=$answ_frac'3' this_nth=5 ;;esac ;;
            '5') case $signal in '<') this_nth=9 ;; '>') this_nth=3 ;;esac ;;
            '6') case $signal in '<') answ_frac=$answ_frac'6' this_nth=5 ;; '>') answ_frac=$answ_frac'5' this_nth=5 ;;esac ;;
            '7') case $signal in '<') this_nth=8 ;; '>') this_nth=6 ;;esac ;;
            '8') case $signal in '<') answ_frac=$answ_frac'8' this_nth=5 ;; '>') answ_frac=$answ_frac'7' this_nth=5 ;;esac ;;
            '9') case $signal in '<') answ_frac=$answ_frac'9' this_nth=5 ;; '>') this_nth=7 ;;esac ;;
        esac
        [ ${#answ_frac} -eq $nthrtsprec ] && break 
    done
    # format output as needed
    case $nthrtsprec in 0) echo ${answ_int%.*} ;;
        *)  while [ ${#answ_frac} -gt $nthrtsprec ] ;do answ_frac=${answ_frac%?*} ;done
            echo ${answ_int%.*}'.'$answ_frac ;;
    esac
} ## nrt_solv
# nthrtsprec= goal_nth= goal= goal_int= answ_int= col= answ_size= this_nth= this_product= signal= answ_frac= nthrtrunc=

# getConst - returns a truncated constant 'e', 'pi' or 'phi'
# used by: 'logx'
# 'getConst e 24' returns 'e' truncated to 24 places
# 'getConst e' alone returns 'e' to 11 places
EE=2.718281828459045235360287471352
ee=2.71828182845
LN10=2.302585092994045684017991454684
ln10=2.30258509299
PI=3.141592653589793238462643383279
pi=3.14159265358
PHI=1.618033988749894848204586834365
phi=1.61803398874
getConst(){ 
    case $1 in e|E) dummy=$EE short=$ee ;; 
        pi|PI) dummy=$PI short=$pi ;; 
        phi|PHI) dummy=$PHI short=$phi ;;
        ln10|LN10) dummy=$LN10 short=$ln10 ;;
        *) echo "-->getConst: Unknown Constant '$1'" >&2 ; return 1 ;; 
    esac
    #[ $2 -gt 30 ] && { echo "-->getConst: Constant length must be <=30" >&2 ; return 1 ;}
    case $2 in ?*) pcnt=-2 pout='' 
        [ $2 -gt 30 ] && { echo "-->getConst: Constant length must be <=30" >&2 ; return 1 ;}
        while [ $pcnt -lt $2 ] ;do 
            pmsk=${dummy#*?} cout=$cout${dummy%$pmsk*} dummy=$pmsk pcnt=$((pcnt+1))
        done
        echo $cout ;; 
        *) echo $short ;;
    esac
} ## getConst
# pcnt= cout= dummy= pmsk=

# exp_z
# depends on: 'add' 'mul' 'div'
# used by: 'exp'
# e^x - an implementation of the very fast and precise Pade approximation of e^x found here:
# https://www.omnimaga.org/math-and-science/pade-expansions-for-approximating-the-exponential-function/
## y=x^2
## a=( (x/2) * ( 1 + (5y/156)*( 1 + (3y/550)*( 1 + (y/1512)) )  /  ( 1 + (3y/26)*( 1 + (5y/396)*( 1 + (y/450)) ) )
## e^x = (1+a)/(1-a)
exp_z() { escale=$defprec
    case $1 in -s*) escale=${1#*-s} ; shift ;; ''|-h) exp_help >&2 ; return 1 ;;esac
    e2scale=$((escale+1))
    expx=$1
    # y = x^2
    y=$( mul -s$e2scale $expx $expx )
    # halfx = x/2
    halfx=$( div -s$e2scale $expx / 2 )
    
    #nom=( 1 + (5y/156)*( 1 + (3y/550))*( 1 + (y/1512)) )
    A=$( div -s$e2scale "$(mul 5 $y)" / 156 )
    B=$( div -s$e2scale "$(mul 3 $y)" / 550 )
    C=$( div -s$e2scale $y / 1512 )
    nom=$( add 1 + $C )
    nom=$( mul -s$e2scale $nom $B)
    nom=$( add 1 + $nom )
    nom=$( mul -s$e2scale $nom $A)
    nom=$( add 1 + $nom )
    
    #denom = ( 1 + (3y/26)*( 1 + (5y/396))*( 1 + (y/450)) )
    X=$( div -s$e2scale "$(mul 3 $y)" / 26 )
    Y=$( div -s$e2scale "$(mul 5 $y)" / 396 )
    Z=$( div -s$e2scale $y / 450 )
    denom=$( add 1 + $Z )
    denom=$( mul -s$e2scale $denom $Y)
    denom=$( add 1 + $denom )
    denom=$( mul -s$e2scale $denom $X)
    denom=$( add 1 + $denom )
    
    # first general ratio
    ratio1=$( div -s$e2scale $nom / $denom )
    # (x/2) * ratio1
    A=$( mul -s$e2scale $ratio1 $halfx )
    
    # e^x = (1+a)/(1-a)
    nom=$( add 1  + $A )
    denom=$( add 1 - $A )
    div -s$escale $nom / $denom
} ## exp_z
## escale= e2scale= expx= y= halfx= A= B= C= nom= X= Y= Z= denom= ratio1=
# operations: 10X mult, 9X div, 8X add

### End back-end functions for pow nroot logx exp

### Trigonometry functions

# sin - Calculate the sine of an angle
# depends on: 'dgrs2rdns' 'sin14' 'cos14' 'tsst' 'add'
# used by 'tan'
sin_help() {
echo "    'sin' usage: 'sin [-s?] angle'
    
    'angle' can be integer or decimal, in degrees 
    Accuracy: 12 places at any 'angle'
    Example usage: 'sin -s6 91.35' = 0.999767
    Example usage: 'sin -s12 29.4567' = 0.491765667756
    "
}
sin(){ out_scale=$defprec
    case $1 in -s*) out_scale=${1#*-s} ; shift ;; ''|'-h') sin_help >&2 ; return ;; esac 
    # raise intermediate scale to retain accuracy
    scale_sin=$((out_scale+2))
    # get the input
    x_sin=$1
    # store and remove signs
    case $x_sin in '-'*) sin_neg='-' x_sin=${x_sin#*-} ;; 
        '+'*) sin_neg='+' x_sin=${x_sin#*+} ;; 
        *) sin_neg='+' ;; 
    esac
    # reduce large x to 360 or less
    while tsst $x_sin -gt 360 ; do
        x_sin=$( add $x_sin - 360 )
    done
    # use symmetry to deduce signage
    negintrmed='+'
    if tsst $x_sin -gt 180 ; then
        negintrmed='-'
    fi
    # determine final sign of result
    case $sin_neg$negintrmed in '--'|'++') sin_neg= ;; '-+'|'+-') sin_neg='-' ;; esac
    # early exit for special cases
    case $x_sin in 
        90|90.0|270|270.0) echo $sin_neg'1' ; return ;;
        30|30.0|330|330.0) echo $sin_neg'0.5' ; return ;;
        180|180.0|360|360.0) echo '0' ; return ;; 
    esac
    # use symmetry to reduce x to <90
    if tsst $x_sin -gt 270 ; then
        x_sin=$( add 360 - $x_sin )
    elif tsst $x_sin -gt 180 ; then
        x_sin=$( add $x_sin -180 )
    elif tsst $x_sin -gt 90 ; then
        x_sin=$( add 180 - $x_sin )
    fi
    
    if tsst $x_sin -gt 35 ; then
        x_sin=$( add 90 - $x_sin )
        x_sin=$( dgrs2rdns -s$scale_sin $x_sin )
        out_sin=$( cos14 -s$out_scale $x_sin )
    else
        x_sin=$( dgrs2rdns -s$scale_sin $x_sin )
        out_sin=$( sin14 -s$out_scale $x_sin )
    fi
    # add the final sign
    echo ${sin_neg}$out_sin
    
} ## sin3
## scale_sn= scale_sin= x_sin= sin_neg= negintrmed= out_scale

# cos - Calculate the cosine of an angle
# depends on: 'dgrs2rdns' 'cos14' 'sin14' 'add' 'tsst'
# used by: 'tan'
cos_help() {
echo "    'cos' usage: 'cos [-s?] angle'
    
    'angle' can be integer or decimal, in degrees 
    Accuracy: ~12 places at any 'angle'
    Example usage: 'cos -s6 28.573' = 0.878208
    Example usage: 'cos -s12 98.827' = -0.153451510933
    "
}
cos(){ scale_cos=$defprec
    case $1 in -s*) scale_cos=${1#*-s} ; shift ;; ''|'-h') cos_help >&2 ; return ;; esac 
    x_cos=$1
    out_scale=$scale_cos
    scale_cos=$((scale_cos+2))
    
    # store and remove sign of input
    case $x_cos in '-'*) cos_neg='-' x_cos=${x_cos#*-} ;; 
        '+'*) cos_neg='+' x_cos=${x_cos#*+} ;; 
        *) cos_neg='+' ;; 
    esac
    # use periodicitiy to reduce
    # large x to 360 or less
    while tsst $x_cos -gt 360 ; do
        x_cos=$( add $x_cos - 360 )
    done
    # early exit for special cases
    case $x_cos in 
        60|60.0|300|300.0) echo '0.5' ; return ;;
        120|120.0|240|240.0) echo '-0.5' ; return ;;
        90|90.0|270|270.0) echo '0' ; return ;; 
        180|180.0) echo '-1' ; return ;;  
        360|360.0) echo '1' ; return ;;
    esac
    
    # use symmetry to further reduce
    negintrmed=''
    if tsst $x_cos -gt 270 ; then
        x_cos=$( add 360 - $x_cos )
    elif tsst $x_cos -gt 180 ; then
        negintrmed='-'
        x_cos=$( add $x_cos - 180 )
    elif tsst $x_cos -gt 90 ; then
        negintrmed='-'
        x_cos=$( add 180 - $x_cos )
    fi
    
    # establish the final sign of output
    case $cos_neg$negintrmed in '--'|'++') cos_neg= ;; '-+'|'+-') cos_neg='-' ;; esac
    
    # get the cosine
    if tsst $x_cos -gt 55 ; then
        x_cos=$( add 90 - $x_cos )
        x_cos=$( dgrs2rdns -s$scale_cos $x_cos )
        out_cos=$( sin14 -s$out_scale $x_cos )
    else
        x_cos=$( dgrs2rdns -s$scale_cos $x_cos )
        out_cos=$( cos14 -s$out_scale $x_cos )
    fi
    # add the final sign
    echo ${negintrmed}$out_cos
} ## cos3
## scale_cos= x_cos= cos_neg= negintrmed= cos_x= out_cos=

# tan - Calcualate the tangent of an angle
# depends on: 'sin' 'cos' 'div' 'tsst' 'add'
# accurate to ~12 digits, except near 90/270, where
# tan 270 or 90 +-0.1 is accurate to 11-digits
# tan 270 or 90 +-0.000001 is accurate to 1-digit 
tan_help() {
echo "    'tan' usage: 'tan [-s?] angle'
    
    'angle' can be integer or decimal, in degrees 
    Accuracy: 12 places for any 'angle', except very
    near 90 or 270, where +-0.1 is accurate to 11-digits
    and 270 or 90 +-0.000001 is accurate to 1-digit
    Example usage: 'tan -s6 28.573' = 0.544606
    Example usage: 'tan -s12 98.827' = -6.439533718717
    "
}
tan() { out_scale=$defprec
    case $1 in -s*) out_scale=${1#*-s} ; shift ;; ''|'-h') tan_help >&2 ; return ;; esac
    scale_tan=$((out_scale+4))
    x_tan=$1
    # establish sign of input
    case $x_tan in '-'*) tan_neg='-' x_tan=${x_tan#*-} ;; 
        '+'*) tan_neg='+' x_tan=${x_tan#*+} ;; 
        *) tan_neg='+' ;; 
    esac
    # use periodicitiy to reduce
    # large x to 360 or less
    while tsst $x_tan -gt 360 ; do
        x_tan=$( add $x_tan - 360 )
    done
    # early exit for special cases
    case $x_tan in 
        90|90.0) echo ${tan_neg#*+}'inf' ; return ;; 
        270|270.0) [ "$tan_neg" = '-' ] &&  echo 'inf' || echo '-inf' ; return ;; 
        180|180.0|360|360.0) echo '0' ; return ;;  
    esac
    
    # use periodicitiy to reduce
    # large x to 180 or less
    while tsst $x_tan -gt 180 ; do
        x_tan=$( add $x_tan - 180 )
    done
    
    # use symmetry to further reduce
    negintrmed='+'
    if tsst $x_tan -gt 90 ; then
        negintrmed='-'
    fi
    
    # establish the real sign of the output
    case $tan_neg$negintrmed in '--'|'++') tan_neg= ;; '-+'|'+-') tan_neg='-' ;; esac
    
    # get the sin and cosin
    si=$( sin -s$scale_tan $x_tan )
    co=$( cos -s$scale_tan $x_tan )
    
    # and divide
    out_tan=$( div -s$out_scale $si / $co )
    # add the final sign
    echo $tan_neg${out_tan#*-}
} ## tan
## out_scale= scale_tan= x_tan= tan_neg= negintrmed= si= co= out_tan=

# cos14 - backend for sin, cos
# depends on: 'mul' 'add'
# used by: 'sin' 'cos'
# the 14.7-digit approximation of cos, from:
# http://www.ganssle.com/item/approximations-for-trig-c-code.htm
# x2 = x*x
# cos(x) = c1 + x2(c2 + x2(c3 + x2(c4 + x2(c5 + x2(c6 + x2(c7 + x2*c8))))))
# inputs are in radians, outputs are in degrees
cos14(){ out_scale=$defprec
    case $1 in -s*) out_scale=${1#*-s} ; shift ;; esac
    x_cos=$1
    scale_cos=$((out_scale+2))
    # x2 = x*x
    x2=$( mul -s$scale_cos $x_cos $x_cos )
    # 8 constants
    c1=0.99999999999999806767
    c2=-0.4999999999998996568
    c3=0.04166666666581174292
    c4=-0.001388888886113613522
    c5=0.000024801582876042427
    c6=-0.0000002755693576863181
    c7=0.0000000020858327958707
    c8=-0.000000000011080716368
    #cos(x)= c1 + x2(c2 + x2(c3 + x2(c4 + x2(c5 + x2(c6 + x2(c7 + x2*c8))))))
    #     out_cos p2  s2  p3  s3  p4  s4  p5  s5  p6  s6  p7  s7   p8
    prod8=$( mul -s$scale_cos $x2 $c8 )
    sum7=$( add $prod8 + $c7 )
    prod7=$( mul -s$scale_cos $x2 $sum7 )
    sum6=$( add $prod7 + $c6 )
    prod6=$( mul -s$scale_cos $x2 $sum6 )
    sum5=$( add $prod6 + $c5 )
    prod5=$( mul -s$scale_cos $x2 $sum5 )
    sum4=$( add $prod5 + $c4 )
    prod4=$( mul -s$scale_cos $x2 $sum4 )
    sum3=$( add $prod4 + $c3 )
    prod3=$( mul -s$scale_cos $x2 $sum3 )
    sum2=$( add $prod3 + $c2 )
    prod2=$( mul -s$scale_cos $x2 $sum2 )
    out_cos=$( add -s$out_scale $prod2 + $c1 )
    echo $out_cos
} ## cos14
# ops 8X mul, 7X add

# sin14 - backend to sin, cos
# depends on: 'mul' 'add' 'div'
# used by: 'sin' 'cos'
##num[x_] = 12671/4363920*x^5 - 2363/18183*x^3 + x;
##den[x_] = 1 + 445/12122*x^2 + 601/872784*x^4 + 121/16662240*x^6;
##si[x_] = num[x]/den[x]
# inputs are in radians, outputs are in degrees
sin14(){ out_scale=$defprec
    case $1 in -s*) out_scale=${1#*-s} ; shift ;; esac
    x_sin=$1
    scale_sin=$((out_scale+2))
    
    # pre-calculated ratios nominator side
    #rat1=( 12671 / 4363920 )   #rat2=( 2363 / 18183 )
    rat1=0.0029035821004968 #01041
    rat2=0.1299565528240664 #35681
    # pre-calculated ratios denominator side
    #rat3=( 445 / 12122 )    #rat4=( 601 / 872784 )   #rat5=( 121 / 16662240 )
    rat3=0.0367101138426002 #30984
    rat4=0.0006886010742635 #06205
    rat5=0.0000072619287682 #80855
    
    # calculate the needed powers of x from x^2 to x^6 
    x2=$( mul -s$scale_sin $x_sin x $x_sin )
    x3=$( mul -s$scale_sin $x2 x $x_sin )
    x4=$( mul -s$scale_sin $x3 x $x_sin )
    x5=$( mul -s$scale_sin $x4 x $x_sin )
    x6=$( mul -s$scale_sin $x5 x $x_sin )
    
    # calculate the numerator 'num'
    prod1=$( mul -s$scale_sin $rat1 x $x5 )
    prod2=$( mul -s$scale_sin $rat2 x $x3 )
    num=$( add  $prod1 - $prod2 + $x_sin )
    
    # calculate the denominator 'den'
    prod3=$( mul -s$scale_sin $rat3 x $x2 )
    prod4=$( mul -s$scale_sin $rat4 x $x4 )
    prod5=$( mul -s$scale_sin $rat5 x $x6 )
    den=$( add 1 + $prod3 + $prod4 + $prod5 )
    
    # rational result
    out_sin=$( div -s$out_scale $num / $den )
    # add the final sign
    echo $out_sin
} ## sin14
## scale_sn= scale_sin= x_sin= sin_neg= negintrmed= out_sin=
## rat1..5=  x2..6=  prod1..5=  num=  den=  r_sin=
# ops 10X mul, 2X add, 1X div

# dgrs2rdns - convert degrees to radians    # x(pi/180)
# depends on: 'mul'
# used by: 'sin' 'cos'
# accurate to ~17 places
dgrs2rdns(){ scale_dg2rd=$defprec
    case $1 in -s*) scale_dg2rd=${1#*-s} ; shift ;; 
        ''|'-h') echo "-->dgrs2rdns: Converts Degrees to Radians" >&2 ; return 1 ;;
    esac 
    mul -s$scale_dg2rd $1 x 0.01745329251994329576 #9236907684 88613
    
} ## dgrs2rdns

# rdns2dgrs - convert radians to degrees     # x(180/pi)
# depends on: 'mul'
# unused, but included for completeness
# accurate to ~15 places
rdns2dgrs(){ scale_rd2dg=$defprec
    case $1 in -s*) scale_rd2dg=${1#*-s} ; shift ;; 
        ''|'-h') echo "-->rdns2dgrs: Converts Radians to Degrees" >&2 ; return 1 ;;
    esac 
    mul -s$scale_rd2dg $1 57.29577951308232087679 #815481410517
} ## rdns2dgrs

### End trigonometry functions

### Miscellaneous functions currently unused elsewhere

# factorial - returns the factorial of an integer input
# depends on: 'mul'
# Example usage: 'factorial 5' returns: '120'
factorial(){ case $1 in -s*) shift ;;esac   # scale is unused and ignored
    case $1 in '') echo "-->factorial: Requires 1 integer input" >&2 ; return 1 ;;
        *.*) echo "-->factorial: Only integer inputs are allowed." >&2 ; return 1 ;;
    esac
    fact_out=$1 fact=$((fact_out-1))
    while [ $fact -gt 1 ] ;do fact_out=$( mul -s0 $fact_out x $fact ) fact=$((fact-1)) ;done
    echo $fact_out
} ## factorial  # fact_out= fact=

# gcf - find the Greatest Common Factor of two integer numbers
# depends on: 'div' 'mul' 'add'
gcf() {  case $1 in -s*) shift ;;esac   # scale is unused and ignored
    case $2 in '') echo "-->gcf: Requires 2 integer inputs" >&2 ; return 1 ;;esac
    case $1"$2" in *.*) echo "-->gcf: Only integer inputs allowed" >&2 ; return 1 ;;esac
    gcf_n1=$1 gcf_n2=$2
    while [ $gcf_n2 -ne 0 ] ; do
        gcf_q=$( div -s0 $gcf_n1 / $gcf_n2 )
        gcf_pp=$( mul -s0 $gcf_q x $gcf_n2 )
        gcf_new2=$( add -s0 $gcf_n1 - $gcf_pp )
        gcf_n1=$gcf_n2  gcf_n2=$gcf_new2
    done
    echo $gcf_n1
} ## gcf  # gcf_n1= gcf_n2= gcf_q= gcf_p= gcf_pp= gcf_new2

# dec2frac - convert a decimal fraction to a whole-number ratio
# depends on: 'div'
dec2frac() { case $1 in -s*) shift ;;esac   # scale is unused and ignored
    case $1 in .?*|0.?*) Nom=${1#*.} ;;
        ''|'-h') echo "-->dec2frac: Requires a decimal fraction input: .12781 or 0.1388" >&2 ; return ;;
        *) echo "-->dec2frac: Only fractions allowed" >&2 ; return 1 ;; 
    esac
    # strip any trailing zeros from the fraction
    while : ;do case $Nom in *'0') Nom=${Nom%?*} ;; *) break ;;esac ;done
    # if now null, it was all zeros
    case $Nom in '') echo "0" ; return ;; esac
    # pad up the denom to one extra digit
    Denom_size=$(( ${#Nom} + 1 ))  Denom=1
    while [ ${#Denom} -lt $Denom_size ] ; do Denom=$Denom'0' ;done
    # strip any leading zeros in the frac
    while : ;do case $Nom in '0'*) Nom=${Nom#*?} ;; *) break ;;esac ;done
    # if number is non-divisible by 5 4 or 2, return fast
    case $Nom in *1|*3|*7|*9) echo $Nom/$Denom ; return ;; esac
    
    cnt=0 runs=$(( (Denom_size/3) + 1 ))
    if [ $Denom_size -lt 19 ] ;then
        while [ $cnt -lt $runs ] ;do
            cnt=$((cnt+1))
            for sim_try in 25 16 8 5 4 2 ;do
                if [ $(( $Nom % $sim_try )) -eq 0 ] && [  $(( $Denom % $sim_try )) -eq 0 ] ;then
                    Nom=$(( $Nom / $sim_try )) ; Denom=$(( $Denom / $sim_try ))
                fi
                [  $Nom -eq 1 ] && break 2 
            done
            [ ${#Denom} -eq $Denom_size ] && break 1
            Denom_size=${#Denom}
        done
    else
        while [ $cnt -lt $runs ] ; do
            cnt=$((cnt+1))
            for sim_try in 25 16 8 5 4 2  ;do
                N_test_sf=$( div $Nom % $sim_try)
                D_test_sf=$( div $Denom % $sim_try )
                if [ "$N_test_sf" = '0' ] && [ "$D_test_sf" = '0' ] ;then
                    Nom=$( div -s0 $Nom / $sim_try ) Denom=$( div -s0 $Denom / $sim_try )
                fi
                [  "$Nom" = 1 ] && break 2
            done
            [ ${#Denom} -eq $Denom_size ] && break 1
            Denom_size=${#Denom}
        done
    fi
    echo $Nom/$Denom
} ## dec2frac
# Nom= Denom= Denom_size= cnt= runs= sim_try= N_test_sf= D_test_sf=

### End Miscellaneous functions

iqXhelp() {
echo "      IQ+ - Version $iqplusversion - Copyright 2022 Gilbert Ashley
    
    iq+ extends the 'iq' calculator, with these functions:
    Power-related functions:  pow  logx  nroot  exp
    Trigonometry functions:   sin  cos   tan
    
    For help and examples, call with no arguments or '-h':
    Example: 'iq+ logx -h' or simply 'iq+ logx'
    
    iq+ usage and syntax builds on that of the 'iq' calculator
    For more on 'iq' syntax and usage, run 'iq -h' or 'iq+ iqhelp'
    'iq' enforces sane inputs, iq+ does not -so GIGO rules apply
    
    From iq+, 'add' and 'mul' require no operators(+-xX), and
    operations on multiple inputs are possible: 'add 3 22.5 -4.1'
    or: 'mul 4.35678 3.4456567 3.223352'. 'add' understands mixed
    signs/operators: 'add 6 -3 1 + -4 - -4' but not 'add 3 --2 +-6'
    For series operations, 'add or 'mul' truncate only final result
    
    The exponent operator '^' is optional with pow functions
    'div' always requires one of these operators: / % 
    
    'logx' returns logarithms in base 2, 'e' or 10 (log2/ln/log)
    'nroot' returns the 'nth' root of a decimal number
    
    Utility functions: factorial gcf dec2frac dgrs2rdns rdns2dgrs
    Accessory functions: ipow epow 
    "
}

# default for execution block
src=${src:-0}

## Execution block
# If 'iq' and 'iq+' are in your PATH use: 'iq+ command'
# Or temporarily add the location of 'iq' to your PATH, like this:
# PATH=path_to_iq:$PATH iq add 23.43578 7234.45
# Otherwise, 'iq' and 'iq+' must be in the users' current working
# directory and you'd then call iq+ like this: './iq+ command'
if [ "1" != "$src" ]  ; then
    # we don't get here if this file has been sourced: 'src=1 . iq+'
    # iq+ needs to source 'iq' for the main functions
    # for debugging, also handle filenames that have a version number 
    case $0 in 
        ./iq+) src=1 . ./iq 
            #. ./iq_misc.sh # uncomment for debugging or testing
            #. ./iq_ai.sh   # of additional iq modules
        ;;
        ./iq+?*) vers=${0#*'+'} ; src=1 . ./iq$vers 
            #. ./iq_misc$vers # uncomment for debugging or testing
            #. ./iq_ai$vers   # of additional iq modules
        ;; 
        *iq+) src=1 . iq ;;
        *iq+?*) vers=${0#*'+'} ; src=1 . iq$vers ;; 
    esac
    # since we are going to do '$cmd "$@"' below, make sure that only our functions
    # can be called, by eliminating the PATH and catching absolute/relative paths
    PATH=
    case $1 in '') iqXhelp >&2 ; exit ;;
        */*) echo "$0: Improper or dangerous input(a path or command): '$1'" ; exit 1 ;;
    esac
    # this the only place iq+ ever executes something and should only
    # recognize its' own functions. In the functions, command-sustitution is
    # used extensively, but only to run other iq/iq+ functions.
    cmd=$1 ; shift
    $cmd "$@" 
    exit $? 
    # exit status for command-line use like: 'iq+ tsst 1111 -gt 1110 && echo greater'
fi
# end of code

# If you want to use these functions and the normal functions from iq in 
# other shell scripts, simply put these lines into your script like this -without the quotes:
# 'src=1 . ./iq'   -or, as above: 'src=1 . iq'
# 'src=1 . ./iq'   -or, as above: 'src=1 . iq+'
# Or, just source 'iq' and copy the functions you need from iq+ into the body of your script.
# See 'example1.sh' for an example of including functions from 'iq' and 'iq+', etc in your script.

# For more complete instructions, see the bottom lines of 'iq' itself

